<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Enhanced Speech-to-Text</title>
    <meta
      name="description"
      content="Advanced speech recognition with translation and note-taking"
    />
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#2c3e50" />
    <style>
      :root {
        --primary-color: #9c27b0;
        --secondary-color: #3498db;
        --warning-color: #f39c12;
        --success-color: #4caf50;
        --danger-color: #e74c3c;
        --dark-color: #2c3e50;
        --light-color: #ecf0f1;
        --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        --font-rtl: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        --transition-speed: 0.2s;
      }

      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: var(--font-main);
        line-height: 1.6;
        margin: 0;
        padding: 0;
        background-color: #f5f7fa;
        color: #333;
        touch-action: manipulation;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #121212;
          color: #e0e0e0;
        }
        .container {
          background-color: #1e1e1e;
        }
        .text-display,
        .notes-display {
          background-color: #2d2d2d;
          border-color: #444;
        }
        .notes-display {
          background-color: #333300;
        }
        .note-item {
          background-color: #333300;
          border-left-color: #666600;
        }
        .translation-panel {
          background-color: #1a237e;
        }
        .translation-result {
          background-color: #1b5e20;
        }
      }

      .container {
        max-width: 100%;
        margin: 0;
        background: white;
        padding: 15px;
        min-height: 100vh;
      }

      h1,
      h2,
      h3 {
        margin-top: 0;
        color: var(--dark-color);
      }

      h1 {
        text-align: center;
        margin-bottom: 20px;
        font-size: 1.5rem;
      }

      .message-box {
        padding: 12px;
        border-radius: 8px;
        margin: 10px 0;
        border-left: 4px solid;
      }

      .android-message {
        background-color: #fff3e0;
        border-left-color: #ffa000;
      }

      .info-message {
        background-color: #e3f2fd;
        border-left-color: #2196f3;
      }

      .control-panel {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 15px;
        justify-content: center;
      }

      button {
        padding: 12px 16px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: all var(--transition-speed);
        font-size: 0.9rem;
        flex: 1 1 120px;
        min-width: 0;
        max-width: 200px;
        touch-action: manipulation;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      button:active {
        transform: scale(0.98);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
      }

      button:hover:not(:disabled) {
        opacity: 0.9;
      }

      #toggleBtn {
        background-color: var(--primary-color);
        color: white;
      }

      #addNoteBtn {
        background-color: var(--secondary-color);
        color: white;
      }

      #clearBtn {
        background-color: var(--warning-color);
        color: white;
      }

      #translateBtn {
        background-color: var(--success-color);
        color: white;
      }

      #exportBtn {
        background-color: #2196f3;
        color: white;
      }

      #importBtn {
        background-color: #607d8b;
        color: white;
      }

      #googleTranslateBtn {
        background-color: #4285f4;
        color: white;
      }

      #downloadAudioBtn {
        background-color: #9c27b0;
        color: white;
      }

      .status {
        text-align: center;
        margin: 12px 0;
        padding: 10px;
        border-radius: 8px;
        background-color: var(--light-color);
        font-size: 0.9rem;
      }

      .transcript-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 15px;
      }

      .text-display,
      .notes-display {
        width: 100%;
        min-height: 150px;
        padding: 12px;
        border-radius: 8px;
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        font-size: 1rem;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      .notes-display {
        background-color: #fffde7;
      }

      .notes-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      .note-item {
        padding: 12px;
        margin-bottom: 10px;
        background-color: #fff9c4;
        border-left: 4px solid #ffd600;
        border-radius: 6px;
        position: relative;
        word-break: break-word;
        transition: transform 0.2s ease;
      }

      .note-item .delete-note {
        position: absolute;
        right: 8px;
        top: 8px;
        background: var(--danger-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        font-size: 14px;
        line-height: 24px;
        text-align: center;
        cursor: pointer;
        padding: 0;
        opacity: 0;
        transition: opacity var(--transition-speed);
      }

      .note-item:hover .delete-note {
        opacity: 1;
      }

      .settings {
        margin-top: 15px;
        padding: 12px;
        background-color: var(--light-color);
        border-radius: 8px;
        font-size: 0.9rem;
      }

      .translation-panel {
        margin-top: 15px;
        padding: 12px;
        background-color: #e3f2fd;
        border-radius: 8px;
      }

      .translation-result {
        margin-top: 10px;
        padding: 10px;
        background-color: #e8f5e9;
        border-radius: 8px;
        min-height: 60px;
        word-break: break-word;
      }

      select,
      input[type="range"] {
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #bdc3c7;
        width: 100%;
        margin-top: 8px;
        font-size: 0.9rem;
        background-color: white;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }

      #targetLanguage {
        margin-top: 10px;
      }

      footer {
        text-align: center;
        margin-top: 20px;
        color: #7f8c8d;
        font-size: 0.8rem;
        padding: 10px;
      }

      .listening-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: var(--success-color);
        margin-right: 8px;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      .offline-status {
        position: fixed;
        bottom: 10px;
        left: 10px;
        padding: 5px 10px;
        background-color: var(--warning-color);
        color: white;
        border-radius: 3px;
        font-size: 12px;
        z-index: 1000;
      }

      .audio-controls {
        margin-top: 15px;
        padding: 12px;
        background-color: #f5f5f5;
        border-radius: 8px;
      }

      .audio-panel {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 10px;
      }

      #audioVisualizer {
        border-radius: 8px;
        overflow: hidden;
        width: 100%;
        height: 80px;
        background-color: #f0f0f0;
        margin-top: 10px;
      }

      .rtl-text {
        direction: rtl;
        text-align: right;
        font-family: var(--font-rtl);
      }

      .confidence-indicator {
        height: 4px;
        background-color: #e0e0e0;
        margin-top: 5px;
        border-radius: 2px;
        overflow: hidden;
      }

      .confidence-level {
        height: 100%;
        background-color: var(--success-color);
        width: 0%;
        transition: width 0.3s ease;
      }

      .export-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        width: 90%;
        max-width: 400px;
      }

      .export-dialog h3 {
        margin-top: 0;
        margin-bottom: 15px;
      }

      .export-dialog button {
        display: block;
        width: 100%;
        margin-bottom: 10px;
        padding: 12px;
      }

      .export-dialog button:last-child {
        margin-bottom: 0;
        background-color: #f5f5f5;
        color: #333;
      }

      .note-item.swiping {
        transition: none;
      }

      .translation-loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top-color: var(--success-color);
        animation: spin 1s ease-in-out infinite;
        margin-right: 8px;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .alert {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        color: white;
        animation: fadeIn 0.3s ease-out;
      }

      .alert-error {
        background-color: var(--danger-color);
      }

      .alert-warning {
        background-color: var(--warning-color);
      }

      .alert-success {
        background-color: var(--success-color);
      }

      .alert-info {
        background-color: var(--secondary-color);
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .icon {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      .install-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        padding: 10px 15px;
        background-color: #4caf50;
        color: white;
        border: none;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .progress-bar {
        height: 4px;
        background-color: rgba(255, 255, 255, 0.3);
        width: 100%;
        margin-top: 8px;
        border-radius: 2px;
        overflow: hidden;
      }

      .progress {
        height: 100%;
        background-color: var(--success-color);
        width: 0%;
        transition: width 0.3s ease;
      }

      @media (min-width: 768px) {
        .container {
          max-width: 900px;
          margin: 0 auto;
          padding: 25px;
          min-height: auto;
        }

        .transcript-container {
          flex-direction: row;
        }

        .text-display,
        .notes-display {
          min-height: 250px;
        }

        select {
          width: auto;
          margin-top: 0;
        }

        button {
          flex: 0 1 auto;
        }
      }

      @media (max-width: 360px) {
        button {
          padding: 10px 12px;
          font-size: 0.8rem;
        }
      }

      @media screen and (-webkit-min-device-pixel-ratio: 0) {
        select,
        textarea,
        input {
          font-size: 16px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Enhanced Speech-to-Text</h1>

      <div class="android-message" id="androidStatus" style="display: none">
        <strong>Android App Status:</strong>
        <span id="androidStatusText">Initializing...</span>
      </div>

      <div class="android-message" id="androidWarning" style="display: none">
        <strong>Note for Android Users:</strong> For best results with local
        languages, use Chrome browser.
      </div>

      <div class="status" id="status">
        <span class="listening-indicator"></span>Initializing speech
        recognition...
      </div>

      <div class="control-panel">
        <button id="toggleBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path
              d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7,9.5V14.5H12V9.5H7M16,9.5V14.5H17V9.5H16Z"
            />
          </svg>
          Start Listening
        </button>
        <button id="addNoteBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
          </svg>
          Add as Note
        </button>
        <button id="clearBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path
              d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z"
            />
          </svg>
          Clear All
        </button>
        <button id="exportBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
          </svg>
          Export Notes
        </button>
        <button id="importBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
          </svg>
          Import Notes
        </button>
        <button id="googleTranslateBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path
              d="M12.87,15.07L10.33,12.56L10.36,12.53C12.1,10.59 13.34,8.36 14.07,6H17V4H10V2H8V4H1V6H12.17C11.5,7.92 10.44,9.75 9,11.35C8.07,10.32 7.3,9.19 6.69,8H4.69C5.42,9.63 6.42,11.17 7.67,12.56L2.58,17.58L4,19L9,14L12.11,17.11L12.87,15.07M18.5,10H16.5L12,22H14L15.12,19H19.87L21,22H23L18.5,10M15.88,17L17.5,12.67L19.12,17H15.88Z"
            />
          </svg>
          Google Translate
        </button>
        <button id="downloadAudioBtn" style="display: none">
          <svg class="icon" viewBox="0 0 24 24">
            <path
              d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M11,16.5L18,9.5L16.59,8.09L11,13.67L7.91,10.59L6.5,12L11,16.5Z"
            />
          </svg>
          Download Audio
        </button>
      </div>

      <div class="transcript-container">
        <div
          class="text-display"
          id="textDisplay"
          contenteditable="true"
          spellcheck="false"
        >
          Your transcribed text will appear here...
        </div>

        <div class="notes-display">
          <h3>Your Notes</h3>
          <div class="progress-bar" id="storageUsageBar">
            <div class="progress" id="storageUsageProgress"></div>
          </div>
          <ul class="notes-list" id="notesList"></ul>
        </div>
      </div>

      <div class="settings">
        <label for="languageSelect">Speech Language:</label>
        <select id="languageSelect">
          <optgroup label="African Languages">
            <option value="am-ET">Amharic (አማርኛ)</option>
            <option value="ti-ET">Tigrinya (ትግርኛ)</option>
            <option value="om-ET">Oromo (Oromoo)</option>
            <option value="so-SO">Somali (Soomaali)</option>
            <option value="ha-NG">Hausa</option>
            <option value="sw-KE">Swahili</option>
          </optgroup>
          <optgroup label="European Languages">
            <option value="en-US" selected>English (US)</option>
            <option value="en-GB">English (UK)</option>
            <option value="es-ES">Spanish (Español)</option>
            <option value="fr-FR">French (Français)</option>
            <option value="de-DE">German (Deutsch)</option>
            <option value="it-IT">Italian (Italiano)</option>
            <option value="pt-BR">Portuguese (Português)</option>
            <option value="ru-RU">Russian (Русский)</option>
          </optgroup>
          <optgroup label="Asian Languages">
            <option value="ar-SA">Arabic (العربية)</option>
            <option value="fa-IR">Persian (فارسی)</option>
            <option value="hi-IN">Hindi (हिन्दी)</option>
            <option value="bn-IN">Bengali (বাংলা)</option>
            <option value="pa-IN">Punjabi (ਪੰਜਾਬੀ)</option>
            <option value="ja-JP">Japanese (日本語)</option>
            <option value="ko-KR">Korean (한국어)</option>
            <option value="zh-CN">Chinese (简体中文)</option>
            <option value="zh-TW">Chinese (繁體中文)</option>
          </optgroup>
        </select>

        <div class="confidence-indicator" id="confidenceIndicator">
          <div class="confidence-level" id="confidenceLevel"></div>
        </div>
      </div>

      <div class="translation-panel">
        <button id="translateBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path
              d="M12.87,15.07L10.33,12.56L10.36,12.53C12.1,10.59 13.34,8.36 14.07,6H17V4H10V2H8V4H1V6H12.17C11.5,7.92 10.44,9.75 9,11.35C8.07,10.32 7.3,9.19 6.69,8H4.69C5.42,9.63 6.42,11.17 7.67,12.56L2.58,17.58L4,19L9,14L12.11,17.11L12.87,15.07M18.5,10H16.5L12,22H14L15.12,19H19.87L21,22H23L18.5,10M15.88,17L17.5,12.67L19.12,17H15.88Z"
            />
          </svg>
          Translate Text
        </button>
        <label for="targetLanguage">Target Language:</label>
        <select id="targetLanguage">
          <optgroup label="African Languages">
            <option value="am">Amharic</option>
            <option value="ti">Tigrinya</option>
            <option value="om">Oromo</option>
            <option value="so" selected>Somali</option>
            <option value="ha">Hausa</option>
            <option value="sw">Swahili</option>
          </optgroup>
          <optgroup label="European Languages">
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
            <option value="it">Italian</option>
            <option value="pt">Portuguese</option>
            <option value="ru">Russian</option>
          </optgroup>
          <optgroup label="Asian Languages">
            <option value="ar">Arabic</option>
            <option value="fa">Persian</option>
            <option value="hi">Hindi</option>
            <option value="bn">Bengali</option>
            <option value="pa">Punjabi</option>
            <option value="ja">Japanese</option>
            <option value="ko">Korean</option>
            <option value="zh">Chinese (Simplified)</option>
            <option value="zh-TW">Chinese (Traditional)</option>
          </optgroup>
        </select>
        <div class="translation-result" id="translationResult"></div>
      </div>

      <div class="audio-controls">
        <h3>Audio Settings</h3>
        <div class="audio-panel">
          <button id="startMicBtn">
            <svg class="icon" viewBox="0 0 24 24">
              <path
                d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"
              />
            </svg>
            Start Microphone
          </button>
          <button id="stopMicBtn" disabled>
            <svg class="icon" viewBox="0 0 24 24">
              <path
                d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z"
              />
            </svg>
            Stop Microphone
          </button>
          <div style="flex: 1; min-width: 150px">
            <label for="volumeControl">Volume:</label>
            <input
              type="range"
              id="volumeControl"
              min="0"
              max="1"
              step="0.1"
              value="0.7"
              style="width: 100%"
            />
          </div>
        </div>
        <label for="audioInputSelect">Microphone Source:</label>
        <select id="audioInputSelect" style="width: 100%; margin-top: 8px">
          <option value="default">Default</option>
        </select>
        <div id="audioVisualizer"></div>
      </div>
    </div>
    <footer>
      Note: Speech recognition and translation require internet, but notes work
      offline.
    </footer>

    <div id="offlineIndicator" class="offline-status" style="display: none">
      OFFLINE MODE
    </div>

    <script>
      // Global variables
      let recognition;
      let isListening = false;
      let isAutoListening = true;
      let finalTranscript = "";
      let audioContext;
      let microphone;
      let analyser;
      let gainNode;
      let isMicActive = false;
      let mediaRecorder;
      let audioChunks = [];
      let audioBlob;
      let audioUrl;
      let touchStartX = 0;
      let touchEndX = 0;
      let lastConfidence = 0;
      let lastFinalTranscript = "";
      let db;
      const DB_NAME = "SpeechNotesDB";
      const DB_VERSION = 2;
      const STORE_NAME = "notes";
      const rtlLanguages = [
        "ar",
        "fa",
        "he",
        "ur",
        "ps",
        "ku",
        "sd",
        "dv",
        "yi",
        "ha",
      ];
      const translationCache = new Map();
      const MAX_STORAGE_QUOTA = 5 * 1024 * 1024; // 5MB
      let lastProcessedIndex = 0; // Track the last processed result index
      let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

      // Initialize the application
      document.addEventListener("DOMContentLoaded", async function () {
        // DOM elements
        const elements = {
          textDisplay: document.getElementById("textDisplay"),
          notesList: document.getElementById("notesList"),
          toggleBtn: document.getElementById("toggleBtn"),
          addNoteBtn: document.getElementById("addNoteBtn"),
          clearBtn: document.getElementById("clearBtn"),
          exportBtn: document.getElementById("exportBtn"),
          importBtn: document.getElementById("importBtn"),
          googleTranslateBtn: document.getElementById("googleTranslateBtn"),
          downloadAudioBtn: document.getElementById("downloadAudioBtn"),
          status: document.getElementById("status"),
          languageSelect: document.getElementById("languageSelect"),
          translateBtn: document.getElementById("translateBtn"),
          targetLanguage: document.getElementById("targetLanguage"),
          translationResult: document.getElementById("translationResult"),
          startMicBtn: document.getElementById("startMicBtn"),
          stopMicBtn: document.getElementById("stopMicBtn"),
          volumeControl: document.getElementById("volumeControl"),
          audioVisualizer: document.getElementById("audioVisualizer"),
          androidWarning: document.getElementById("androidWarning"),
          audioInputSelect: document.getElementById("audioInputSelect"),
          androidStatus: document.getElementById("androidStatus"),
          androidStatusText: document.getElementById("androidStatusText"),
          storageUsageProgress: document.getElementById("storageUsageProgress"),
        };

        // Initialize platform-specific features
        initPlatformSpecificFeatures(elements);

        // Initialize database and load notes
        await initDB();
        loadNotesFromDB(elements.notesList);

        // Initialize speech recognition
        initSpeechRecognition(elements);

        // Set up event listeners
        setupEventListeners(elements);

        // Check online status
        updateOnlineStatus();
      });

      // Platform-specific initialization
      function initPlatformSpecificFeatures(elements) {
        if (isAndroid()) {
          elements.androidWarning.style.display = "block";
          if (!/Chrome/i.test(navigator.userAgent)) {
            elements.androidWarning.innerHTML +=
              "<br><br><strong>Recommendation:</strong> Use Chrome for best results";
          }
        }

        if (isIOS()) {
          const iosMessage = document.createElement("div");
          iosMessage.className = "info-message";
          iosMessage.innerHTML =
            "<strong>iOS Users:</strong> Use Safari for best results";
          document
            .querySelector(".container")
            .insertBefore(iosMessage, elements.status);
        }
      }

      // Database functions
      async function initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);

          request.onerror = (event) => {
            console.error("Database error:", event.target.error);
            showAlert("Failed to initialize database", "error");
            reject(event.target.error);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              const store = db.createObjectStore(STORE_NAME, {
                keyPath: "id",
                autoIncrement: true,
              });
              store.createIndex("timestamp", "timestamp", { unique: false });
              store.createIndex("language", "language", { unique: false });
            }
          };

          request.onsuccess = (event) => {
            db = event.target.result;
            updateStorageUsage();
            resolve(db);
          };
        });
      }

      async function loadNotesFromDB(notesList) {
        try {
          const notes = await getAllNotesFromDB();
          notes.forEach((note) => {
            addNoteToUI(note.text, note.id, note.language, notesList);
          });
        } catch (error) {
          console.error("Failed to load notes:", error);
          showAlert("Failed to load notes from storage", "error");
        }
      }

      async function getAllNotesFromDB() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.getAll();

          request.onsuccess = () => resolve(request.result);
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function saveNoteToDB(text, language) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);

          const note = {
            text: text,
            language: language,
            timestamp: new Date().toISOString(),
          };

          const request = store.add(note);

          request.onsuccess = () => {
            updateStorageUsage();
            resolve(request.result);
          };
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function deleteNoteFromDB(id) {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.delete(id);

          request.onsuccess = () => {
            updateStorageUsage();
            resolve(true);
          };
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function clearAllNotesFromDB() {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.clear();

          request.onsuccess = () => {
            updateStorageUsage();
            resolve(true);
          };
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function updateStorageUsage() {
        if (!db) return;

        try {
          const notes = await getAllNotesFromDB();
          const totalSize = JSON.stringify(notes).length;
          const percentage = Math.min(
            100,
            (totalSize / MAX_STORAGE_QUOTA) * 100
          );

          const progressBar = document.getElementById("storageUsageProgress");
          if (progressBar) {
            progressBar.style.width = `${percentage}%`;

            if (percentage > 90) {
              progressBar.style.backgroundColor = "var(--danger-color)";
              showAlert(
                "Storage almost full - consider exporting notes",
                "warning"
              );
            } else if (percentage > 70) {
              progressBar.style.backgroundColor = "var(--warning-color)";
            } else {
              progressBar.style.backgroundColor = "var(--success-color)";
            }
          }
        } catch (error) {
          console.error("Error calculating storage usage:", error);
        }
      }

      // Speech recognition functions
      function initSpeechRecognition(elements) {
        if (
          !("webkitSpeechRecognition" in window) &&
          !("SpeechRecognition" in window)
        ) {
          elements.status.innerHTML =
            '<span style="color:red;">Speech recognition not supported in your browser</span>';
          elements.toggleBtn.disabled = true;
          elements.addNoteBtn.disabled = true;
          return;
        }

        const SpeechRecognition =
          window.SpeechRecognition || window.webkitSpeechRecognition;
        recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.maxAlternatives = 1;
        recognition.lang = elements.languageSelect.value;

        recognition.onresult = (event) => {
          let interimTranscript = "";
          let newFinalTranscript = "";
          let hasNewFinal = false;

          // Only process new results since last processed index
          for (let i = Math.max(lastProcessedIndex, event.resultIndex); i < event.results.length; i++) {
            const result = event.results[i];
            const transcript = result[0].transcript;
            const confidence = result[0].confidence || 0;

            if (result.isFinal) {
              newFinalTranscript += transcript + " ";
              lastFinalTranscript = newFinalTranscript;
              hasNewFinal = true;
            } else {
              interimTranscript = transcript;
            }

            if (confidence > lastConfidence) {
              lastConfidence = confidence;
              updateConfidenceIndicator(confidence, elements.confidenceLevel);
            }
          }

          // Update last processed index
          lastProcessedIndex = event.results.length - 1;

          // On mobile, we need to be more careful with interim results
          if (isMobile) {
            if (hasNewFinal) {
              finalTranscript += newFinalTranscript;
              interimTranscript = ""; // Clear interim when we have final
            }
          } else {
            if (newFinalTranscript) {
              finalTranscript += newFinalTranscript;
            }
          }

          updateTextDisplay(
            finalTranscript,
            interimTranscript,
            elements.textDisplay,
            elements.languageSelect.value
          );
        };

        recognition.onerror = (event) => {
          console.error("Recognition error:", event.error);
          isListening = false;
          lastProcessedIndex = 0; // Reset index on error

          let errorMessage = "Error occurred in recognition";
          switch (event.error) {
            case "no-speech":
              errorMessage = "No speech detected";
              break;
            case "audio-capture":
              errorMessage = "Microphone not available";
              break;
            case "not-allowed":
              errorMessage = "Microphone access denied";
              break;
            case "language-not-supported":
              errorMessage = "Language not supported";
              break;
          }

          elements.status.innerHTML = `<span style="color:red;">${errorMessage}</span>`;
          elements.status.style.backgroundColor = "#ffebee";
          elements.toggleBtn.textContent = "Start Listening";

          setTimeout(() => {
            if (isAutoListening) recognition.start();
          }, 1000);
        };

        recognition.onstart = () => {
          isListening = true;
          lastProcessedIndex = 0; // Reset index when starting
          elements.status.innerHTML =
            '<span class="listening-indicator"></span>Listening... Speak now!';
          elements.status.style.backgroundColor = "#e8f5e9";
          elements.toggleBtn.textContent = "Pause Listening";
          updateConfidenceIndicator(0, elements.confidenceLevel);
        };

        recognition.onend = () => {
          if (isAutoListening) {
            setTimeout(() => {
              try {
                recognition.start();
              } catch (e) {
                console.log("Auto-restart failed, retrying...", e);
                setTimeout(() => isAutoListening && recognition.start(), 300);
              }
            }, 100);
          }
        };

        // Start initial listening if online
        if (navigator.onLine) {
          setTimeout(() => recognition.start(), 300);
        }
      }

      // UI update functions
      function updateTextDisplay(final, interim, textDisplay, language) {
        if ("requestIdleCallback" in window) {
          requestIdleCallback(
            () =>
              updateTextDisplayImmediately(
                final,
                interim,
                textDisplay,
                language
              ),
            { timeout: 100 }
          );
        } else {
          updateTextDisplayImmediately(final, interim, textDisplay, language);
        }
      }

      function updateTextDisplayImmediately(
        final,
        interim,
        textDisplay,
        language
      ) {
        if (!final && !interim) return;

        let newContent = final;
        
        // Only append interim results if they're different from the last final result
        if (interim && !final.endsWith(interim.trim())) {
          newContent += (final ? " " : "") + '<span style="color:#aaa;">' + interim + "</span>";
        }

        if (!interim) {
          textDisplay.textContent = newContent;
        } else {
          textDisplay.innerHTML = newContent;
        }

        applyTextDirection(textDisplay, language);
      }

      function applyTextDirection(element, languageCode) {
        const baseLang = languageCode.split("-")[0];
        if (rtlLanguages.includes(baseLang)) {
          element.classList.add("rtl-text");
        } else {
          element.classList.remove("rtl-text");
        }
      }

      function updateConfidenceIndicator(confidence, confidenceLevel) {
        if (!confidenceLevel) return;

        const percentage = Math.round(confidence * 100);
        confidenceLevel.style.width = `${percentage}%`;

        if (percentage > 80) {
          confidenceLevel.style.backgroundColor = "var(--success-color)";
        } else if (percentage > 50) {
          confidenceLevel.style.backgroundColor = "var(--warning-color)";
        } else {
          confidenceLevel.style.backgroundColor = "var(--danger-color)";
        }
      }

      function addNoteToUI(text, id, language, notesList) {
        const noteItem = document.createElement("li");
        noteItem.className = "note-item";
        noteItem.dataset.id = id || Date.now();

        const noteText = document.createElement("span");
        noteText.textContent = text;

        if (language) {
          const baseLang = language.split("-")[0];
          if (rtlLanguages.includes(baseLang)) {
            noteItem.classList.add("rtl-text");
          }
        }

        const deleteBtn = document.createElement("button");
        deleteBtn.className = "delete-note";
        deleteBtn.innerHTML = "×";
        deleteBtn.addEventListener("click", async () => {
          if (confirm("Delete this note?")) {
            noteItem.remove();
            if (id) {
              try {
                await deleteNoteFromDB(id);
                showAlert("Note deleted", "success");
              } catch (error) {
                console.error("Failed to delete note:", error);
                showAlert("Failed to delete note from storage", "error");
              }
            }
          }
        });

        // Touch events for mobile
        noteItem.addEventListener(
          "touchstart",
          (e) => {
            touchStartX = e.changedTouches[0].screenX;
            noteItem.classList.add("swiping");
          },
          { passive: true }
        );

        noteItem.addEventListener(
          "touchmove",
          (e) => {
            touchEndX = e.changedTouches[0].screenX;
            const diff = touchStartX - touchEndX;
            if (diff > 30) {
              noteItem.style.transform = `translateX(${-diff}px)`;
              if (diff > 100) {
                deleteBtn.style.opacity = "1";
              }
            }
          },
          { passive: true }
        );

        noteItem.addEventListener(
          "touchend",
          () => {
            noteItem.classList.remove("swiping");
            const diff = touchStartX - touchEndX;
            if (diff > 100) {
              deleteBtn.click();
            } else {
              noteItem.style.transform = "";
            }
          },
          { passive: true }
        );

        noteItem.appendChild(noteText);
        noteItem.appendChild(deleteBtn);
        notesList.appendChild(noteItem);
        noteItem.scrollIntoView({ behavior: "smooth" });
      }

      // Audio functions
      async function startMicrophone(elements) {
        try {
          // Stop existing microphone if active
          if (isMicActive) {
            stopMicrophone();
          }

          // Initialize audio context
          if (!audioContext) {
            audioContext = new (window.AudioContext ||
              window.webkitAudioContext)({
              latencyHint: "interactive",
              sampleRate: 16000,
            });
          }

          // Get selected device
          const deviceId =
            elements.audioInputSelect.value === "default"
              ? undefined
              : elements.audioInputSelect.value;

          // Get user media
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              deviceId: deviceId,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
              channelCount: 1,
            },
            video: false,
          });

          // Create audio nodes
          gainNode = audioContext.createGain();
          gainNode.gain.value = elements.volumeControl.value;

          analyser = audioContext.createAnalyser();
          analyser.fftSize = 256;

          // Connect nodes
          microphone = audioContext.createMediaStreamSource(stream);

          if (audioContext.createAudioWorklet) {
            try {
              const blob = new Blob(
                [
                  `
              class AudioProcessor extends AudioWorkletProcessor {
                process(inputs, outputs) {
                  const input = inputs[0];
                  const output = outputs[0];
                  for (let channel = 0; channel < input.length; ++channel) {
                    output[channel].set(input[channel]);
                  }
                  return true;
                }
              }
              registerProcessor('audio-processor', AudioProcessor);
            `,
                ],
                { type: "application/javascript" }
              );

              const url = URL.createObjectURL(blob);
              await audioContext.audioWorklet.addModule(url);
              const workletNode = new AudioWorkletNode(
                audioContext,
                "audio-processor"
              );
              microphone.connect(workletNode).connect(analyser);
            } catch (e) {
              console.warn(
                "AudioWorklet not available, using script processor"
              );
              const scriptNode = audioContext.createScriptProcessor(4096, 1, 1);
              microphone.connect(scriptNode).connect(analyser);
            }
          } else {
            microphone.connect(gainNode).connect(analyser);
          }

          analyser.connect(audioContext.destination);

          // Setup visualization
          setupVisualizer(elements.audioVisualizer);

          // Setup recording
          mediaRecorder = new MediaRecorder(stream);
          audioChunks = [];

          mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) audioChunks.push(e.data);
          };

          mediaRecorder.onstop = () => {
            audioBlob = new Blob(audioChunks, { type: "audio/wav" });
            audioUrl = URL.createObjectURL(audioBlob);
            elements.downloadAudioBtn.style.display = "block";
          };

          mediaRecorder.start(100);
          isMicActive = true;

          // Update UI
          elements.startMicBtn.disabled = true;
          elements.stopMicBtn.disabled = false;
          elements.status.innerHTML =
            '<span class="listening-indicator"></span>Microphone active';
        } catch (error) {
          console.error("Microphone error:", error);
          showAlert("Microphone access denied or unavailable", "error");
        }
      }

      function stopMicrophone() {
        if (!isMicActive) return;

        if (mediaRecorder && mediaRecorder.state !== "inactive") {
          mediaRecorder.stop();
        }

        if (microphone) microphone.disconnect();
        if (gainNode) gainNode.disconnect();
        if (analyser) analyser.disconnect();

        isMicActive = false;
      }

      function setupVisualizer(audioVisualizer) {
        const canvas = document.createElement("canvas");
        canvas.width = audioVisualizer.offsetWidth;
        canvas.height = audioVisualizer.offsetHeight;
        audioVisualizer.innerHTML = "";
        audioVisualizer.appendChild(canvas);

        const canvasCtx = canvas.getContext("2d");
        const bufferLength = analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        let animationId;

        function draw() {
          if (!isMicActive) {
            cancelAnimationFrame(animationId);
            return;
          }

          animationId = requestAnimationFrame(draw);
          analyser.getByteFrequencyData(dataArray);

          canvasCtx.fillStyle = "rgb(200, 200, 200)";
          canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

          const barWidth = (canvas.width / bufferLength) * 2.5;
          let x = 0;

          for (let i = 0; i < bufferLength; i++) {
            const barHeight = dataArray[i] / 2;
            const hue = (i / bufferLength) * 360;

            canvasCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            canvasCtx.fillRect(
              x,
              canvas.height - barHeight,
              barWidth,
              barHeight
            );

            x += barWidth + 1;
          }
        }

        draw();
      }

      // Translation functions
      async function translateText(text, targetLang) {
        if (!text?.trim()) return "";

        // Check cache first
        const cacheKey = `${text}-${targetLang}`;
        if (translationCache.has(cacheKey)) {
          return translationCache.get(cacheKey);
        }

        try {
          // Try LibreTranslate first
          const libreResult = await translateWithLibre(text, targetLang);
          if (libreResult) {
            translationCache.set(cacheKey, libreResult);
            return libreResult;
          }

          // Fallback to MyMemory
          const myMemoryResult = await translateWithMyMemory(text, targetLang);
          if (myMemoryResult) {
            translationCache.set(cacheKey, myMemoryResult);
            return myMemoryResult;
          }

          // Final fallback
          return localFallbackTranslation(text, targetLang);
        } catch (error) {
          console.error("Translation error:", error);
          return localFallbackTranslation(text, targetLang);
        }
      }

      async function translateWithLibre(text, targetLang) {
        try {
          const response = await fetch("https://libretranslate.com/translate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              q: text,
              source: "auto",
              target: targetLang,
              format: "text",
            }),
          });

          if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
          const data = await response.json();
          return data.translatedText;
        } catch (error) {
          console.warn("LibreTranslate failed:", error);
          return null;
        }
      }

      async function translateWithMyMemory(text, targetLang) {
        try {
          const MAX_CHUNK_SIZE = 4000;
          const chunks = [];

          for (let i = 0; i < text.length; i += MAX_CHUNK_SIZE) {
            chunks.push(text.substring(i, i + MAX_CHUNK_SIZE));
          }

          const translatedChunks = await Promise.all(
            chunks.map((chunk) => translateMyMemoryChunk(chunk, targetLang))
          );

          return translatedChunks.join(" ");
        } catch (error) {
          console.warn("MyMemory failed:", error);
          return null;
        }
      }

      async function translateMyMemoryChunk(chunk, targetLang) {
        const response = await fetch(
          `https://api.mymemory.translated.net/get?q=${encodeURIComponent(
            chunk
          )}&langpair=auto|${targetLang}`
        );

        if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
        const data = await response.json();
        return data.responseData?.translatedText || chunk;
      }

      function localFallbackTranslation(text, targetLang) {
        const translations = {
          en: { hello: "hello", "thank you": "thank you" },
          es: { hello: "hola", "thank you": "gracias" },
          so: { hello: "salaam", "thank you": "mahadsanid" },
        };

        const langCode = targetLang.split("-")[0];
        const lowerText = text.toLowerCase().trim();

        if (translations[langCode]?.[lowerText]) {
          return translations[langCode][lowerText];
        }

        return `${text} [Translation failed for ${targetLang}]`;
      }

      function openGoogleTranslate(text, sourceLang, targetLang) {
        const langMap = {
          am: "am",
          ti: "ti",
          om: "om",
          so: "so",
          ha: "ha",
          sw: "sw",
          en: "en",
          es: "es",
          fr: "fr",
          de: "de",
          it: "it",
          pt: "pt",
          ru: "ru",
          ar: "ar",
          fa: "fa",
          hi: "hi",
          bn: "bn",
          pa: "pa",
          ja: "ja",
          ko: "ko",
          zh: "zh-CN",
          "zh-TW": "zh-TW",
        };

        const sourceCode = langMap[sourceLang.split("-")[0]] || "auto";
        const targetCode = langMap[targetLang] || "en";

        window.open(
          `https://translate.google.com/?sl=${sourceCode}&tl=${targetCode}&text=${encodeURIComponent(
            text
          )}&op=translate`,
          "_blank"
        );
      }

      // Utility functions
      function showAlert(message, type = "info") {
        const alertDiv = document.createElement("div");
        alertDiv.className = `alert alert-${type}`;
        alertDiv.textContent = message;
        document.body.appendChild(alertDiv);

        setTimeout(() => {
          alertDiv.style.opacity = "0";
          setTimeout(() => alertDiv.remove(), 300);
        }, 3000);
      }

      function updateOnlineStatus() {
        const offlineIndicator = document.getElementById("offlineIndicator");
        if (navigator.onLine) {
          offlineIndicator.style.display = "none";
        } else {
          offlineIndicator.style.display = "block";
        }
      }

      function isAndroid() {
        return /Android/i.test(navigator.userAgent);
      }

      function isIOS() {
        return /iPhone|iPad|iPod/i.test(navigator.userAgent);
      }

      // Event listener setup
      function setupEventListeners(elements) {
        // Auto-save draft
        let draftTimer;
        elements.textDisplay.addEventListener("input", () => {
          clearTimeout(draftTimer);
          draftTimer = setTimeout(() => {
            localStorage.setItem(
              "speechDraft",
              elements.textDisplay.textContent
            );
          }, 5000);
        });

        // Restore draft on load
        const draft = localStorage.getItem("speechDraft");
        if (draft) {
          elements.textDisplay.textContent = draft;
          showAlert("Restored unsaved draft", "success");
        }

        // Toggle listening
        elements.toggleBtn.addEventListener("click", function () {
          this.disabled = true;

          if (isListening) {
            isAutoListening = false;
            recognition.stop();
            isListening = false;
            this.textContent = "Start Listening";
            elements.status.textContent = "Listening paused.";
          } else {
            isAutoListening = true;
            recognition.lang = elements.languageSelect.value;
            recognition.start();
          }

          setTimeout(() => (this.disabled = false), 300);
        });

        // Add note
        elements.addNoteBtn.addEventListener("click", async () => {
          const text = elements.textDisplay.textContent.trim();
          if (!text || text === "Your transcribed text will appear here...") {
            showAlert("No text to save as note", "warning");
            return;
          }

          const language = elements.languageSelect.value;
          try {
            const noteId = await saveNoteToDB(text, language);
            addNoteToUI(text, noteId, language, elements.notesList);
            elements.textDisplay.textContent = "";
            finalTranscript = "";
            localStorage.removeItem("speechDraft");
            showAlert("Note saved", "success");
          } catch (error) {
            console.error("Save failed:", error);
            addNoteToUI(text, null, language, elements.notesList);
            elements.textDisplay.textContent = "";
            finalTranscript = "";
            localStorage.removeItem("speechDraft");
            showAlert("Note saved locally (not synced)", "warning");
          }
        });

        // Clear all
        elements.clearBtn.addEventListener("click", async () => {
          if (confirm("Clear all notes? This cannot be undone.")) {
            elements.textDisplay.textContent = "";
            elements.notesList.innerHTML = "";
            finalTranscript = "";

            try {
              await clearAllNotesFromDB();
              localStorage.removeItem("speechDraft");
              showAlert("All notes cleared", "success");
            } catch (error) {
              console.error("Clear failed:", error);
              showAlert("Failed to clear notes from storage", "error");
            }
          }
        });

        // Export notes
        elements.exportBtn.addEventListener("click", async () => {
          try {
            const notes = await getAllNotesFromDB();
            if (notes.length === 0) {
              showAlert("No notes to export", "warning");
              return;
            }

            const exportDialog = document.createElement("div");
            exportDialog.className = "export-dialog";
            exportDialog.innerHTML = `
            <h3>Export Options</h3>
            <button id="exportDocx">Export as Word (.docx)</button>
            <button id="exportTxt">Export as Text (.txt)</button>
            <button id="exportCancel">Cancel</button>
          `;

            document.body.appendChild(exportDialog);

            document
              .getElementById("exportDocx")
              .addEventListener("click", async () => {
                await exportAsDocx(notes);
                exportDialog.remove();
              });

            document
              .getElementById("exportTxt")
              .addEventListener("click", async () => {
                await exportAsTxt(notes);
                exportDialog.remove();
              });

            document
              .getElementById("exportCancel")
              .addEventListener("click", () => {
                exportDialog.remove();
              });
          } catch (error) {
            console.error("Export failed:", error);
            showAlert("Failed to export notes", "error");
          }
        });

        async function exportAsDocx(notes) {
          try {
            const { default: docx } = await import(
              "https://cdn.jsdelivr.net/npm/docx@7.8.2/+esm"
            );
            const { Document, Paragraph, TextRun, Packer } = docx;

            const doc = new Document({
              sections: [
                {
                  properties: {},
                  children: [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: "Speech Notes Export",
                          bold: true,
                        }),
                      ],
                    }),
                    ...notes.map((note) => new Paragraph({ text: note.text })),
                  ],
                },
              ],
            });

            const blob = await Packer.toBlob(doc);
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `speech-notes-${
              new Date().toISOString().split("T")[0]
            }.docx`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 100);
          } catch (error) {
            console.error("DOCX export failed:", error);
            throw error;
          }
        }

        async function exportAsTxt(notes) {
          try {
            const text = notes.map((n) => n.text).join("\n\n");
            const blob = new Blob([text], { type: "text/plain" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `speech-notes-${
              new Date().toISOString().split("T")[0]
            }.txt`;
            a.click();
            setTimeout(() => URL.revokeObjectURL(url), 100);
          } catch (error) {
            console.error("TXT export failed:", error);
            throw error;
          }
        }

        // Import notes
        elements.importBtn.addEventListener("click", () => {
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".docx,.txt";

          fileInput.addEventListener("change", async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
              let notes = [];
              if (file.name.endsWith(".docx")) {
                const { default: mammoth } = await import(
                  "https://cdn.jsdelivr.net/npm/mammoth@1.4.0/+esm"
                );
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({ arrayBuffer });
                notes = result.value
                  .split("\n")
                  .filter((l) => l.trim())
                  .map((t) => ({ text: t }));
              } else {
                const text = await file.text();
                notes = text
                  .split("\n")
                  .filter((l) => l.trim())
                  .map((t) => ({ text: t }));
              }

              // Clear existing
              elements.notesList.innerHTML = "";
              try {
                await clearAllNotesFromDB();
              } catch {}

              // Add new notes
              let successCount = 0;
              for (const note of notes) {
                try {
                  const noteId = await saveNoteToDB(
                    note.text,
                    elements.languageSelect.value
                  );
                  addNoteToUI(
                    note.text,
                    noteId,
                    elements.languageSelect.value,
                    elements.notesList
                  );
                  successCount++;
                } catch (error) {
                  addNoteToUI(
                    note.text,
                    null,
                    elements.languageSelect.value,
                    elements.notesList
                  );
                }
              }

              showAlert(`Imported ${successCount} notes`, "success");
            } catch (error) {
              console.error("Import failed:", error);
              showAlert("Failed to import notes", "error");
            }
          });

          fileInput.click();
        });

        // Google Translate
        elements.googleTranslateBtn.addEventListener("click", () => {
          const text = elements.textDisplay.textContent.trim();
          if (!text || text === "Your transcribed text will appear here...") {
            showAlert("No text to translate", "warning");
            return;
          }

          openGoogleTranslate(
            text,
            elements.languageSelect.value,
            elements.targetLanguage.value
          );
        });

        // Translate
        elements.translateBtn.addEventListener("click", async () => {
          const text = elements.textDisplay.textContent.trim();
          if (!text || text === "Your transcribed text will appear here...") {
            showAlert("No text to translate", "warning");
            return;
          }

          if (!navigator.onLine) {
            showAlert("Translation requires internet", "warning");
            return;
          }

          try {
            elements.translateBtn.disabled = true;
            elements.translateBtn.innerHTML =
              '<span class="translation-loading"></span>Translating...';
            elements.translationResult.textContent = "";

            const translation = await translateText(
              text,
              elements.targetLanguage.value
            );
            elements.translationResult.textContent = translation;
            applyTextDirection(
              elements.translationResult,
              elements.targetLanguage.value
            );
          } catch (error) {
            console.error("Translation failed:", error);
            showAlert("Translation failed", "error");
            elements.translationResult.textContent = "Error: " + error.message;
          } finally {
            elements.translateBtn.disabled = false;
            elements.translateBtn.textContent = "Translate Text";
          }
        });

        // Audio controls
        elements.startMicBtn.addEventListener("click", () =>
          startMicrophone(elements)
        );
        elements.stopMicBtn.addEventListener("click", () => {
          stopMicrophone();
          elements.startMicBtn.disabled = false;
          elements.stopMicBtn.disabled = true;
        });

        elements.downloadAudioBtn.addEventListener("click", () => {
          if (audioUrl) {
            const a = document.createElement("a");
            a.href = audioUrl;
            a.download = `recording-${new Date()
              .toISOString()
              .replace(/[:.]/g, "-")}.wav`;
            a.click();
          }
        });

        elements.volumeControl.addEventListener("input", () => {
          if (gainNode) gainNode.gain.value = elements.volumeControl.value;
        });

        // Language change
        elements.languageSelect.addEventListener("change", () => {
          if (recognition) {
            recognition.lang = elements.languageSelect.value;
            applyTextDirection(
              elements.textDisplay,
              elements.languageSelect.value
            );
            if (isListening) {
              recognition.stop();
              setTimeout(() => recognition.start(), 100);
            }
          }
        });

        // Audio input devices
        async function updateAudioInputs() {
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputs = devices.filter((d) => d.kind === "audioinput");

            while (elements.audioInputSelect.options.length > 1) {
              elements.audioInputSelect.remove(1);
            }

            audioInputs.forEach((device) => {
              const option = document.createElement("option");
              option.value = device.deviceId;
              option.text =
                device.label ||
                `Microphone ${elements.audioInputSelect.options.length}`;
              elements.audioInputSelect.appendChild(option);
            });
          } catch (err) {
            console.error("Device enumeration failed:", err);
          }
        }

        updateAudioInputs();
        navigator.mediaDevices.addEventListener(
          "devicechange",
          updateAudioInputs
        );

        // Online/offline status
        window.addEventListener("online", updateOnlineStatus);
        window.addEventListener("offline", updateOnlineStatus);

        // Page visibility
        document.addEventListener("visibilitychange", () => {
          if (document.visibilityState === "hidden" && isListening) {
            recognition.stop();
          } else if (
            document.visibilityState === "visible" &&
            isAutoListening
          ) {
            setTimeout(() => recognition.start(), 100);
          }
        });

        // Beforeunload
        window.addEventListener("beforeunload", () => {
          if (isListening) recognition.stop();
          if (isMicActive) stopMicrophone();
        });

        // PWA installation
        let deferredPrompt;
        window.addEventListener("beforeinstallprompt", (e) => {
          e.preventDefault();
          deferredPrompt = e;

          const installBtn = document.createElement("button");
          installBtn.className = "install-btn";
          installBtn.innerHTML = `
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M11,16.5L18,9.5L16.59,8.09L11,13.67L7.91,10.59L6.5,12L11,16.5Z" />
          </svg>
          Install App
        `;

          installBtn.addEventListener("click", () => {
            deferredPrompt.prompt();
            deferredPrompt.userChoice.then((choice) => {
              if (choice.outcome === "accepted") {
                installBtn.remove();
              }
            });
          });

          document.body.appendChild(installBtn);

          setTimeout(() => {
            if (document.body.contains(installBtn)) {
              installBtn.remove();
            }
          }, 15000);
        });
      }

      // Service worker registration
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker.register("sw.js").catch((err) => {
            console.error("ServiceWorker failed:", err);
          });
        });
      }
    </script>
  </body>
</html>
