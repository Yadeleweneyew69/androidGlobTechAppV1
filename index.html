<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Local Language Speech to Text</title>
    <meta name="description" content="Speech to text application supporting multiple local languages with translation capabilities">
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#2c3e50" />
    <style>
      :root {
        --primary-color: #9c27b0;
        --secondary-color: #3498db;
        --warning-color: #f39c12;
        --success-color: #4caf50;
        --danger-color: #e74c3c;
        --dark-color: #2c3e50;
        --light-color: #ecf0f1;
        --font-main: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        --font-rtl: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        --transition-speed: 0.2s;
      }

      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        font-family: var(--font-main);
        line-height: 1.6;
        margin: 0;
        padding: 0;
        background-color: #f5f7fa;
        color: #333;
        touch-action: manipulation;
      }

      @media (prefers-color-scheme: dark) {
        body {
          background-color: #121212;
          color: #e0e0e0;
        }
        .container {
          background-color: #1e1e1e;
        }
        .text-display,
        .notes-display {
          background-color: #2d2d2d;
          border-color: #444;
        }
        .notes-display {
          background-color: #333300;
        }
        .note-item {
          background-color: #333300;
          border-left-color: #666600;
        }
        .translation-panel {
          background-color: #1a237e;
        }
        .translation-result {
          background-color: #1b5e20;
        }
      }

      .container {
        max-width: 100%;
        margin: 0;
        background: white;
        padding: 15px;
        min-height: 100vh;
      }

      h1, h2, h3 {
        margin-top: 0;
        color: var(--dark-color);
      }

      h1 {
        text-align: center;
        margin-bottom: 20px;
        font-size: 1.5rem;
      }

      .message-box {
        padding: 12px;
        border-radius: 8px;
        margin: 10px 0;
        border-left: 4px solid;
      }

      .android-message {
        background-color: #fff3e0;
        border-left-color: #ffa000;
      }

      .info-message {
        background-color: #e3f2fd;
        border-left-color: #2196f3;
      }

      .control-panel {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 15px;
        justify-content: center;
      }

      button {
        padding: 12px 16px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-weight: bold;
        transition: all var(--transition-speed);
        font-size: 0.9rem;
        flex: 1 1 120px;
        min-width: 0;
        max-width: 200px;
        touch-action: manipulation;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 6px;
      }

      button:active {
        transform: scale(0.98);
      }

      button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none !important;
      }

      button:hover:not(:disabled) {
        opacity: 0.9;
      }

      #toggleBtn {
        background-color: var(--primary-color);
        color: white;
      }

      #addNoteBtn {
        background-color: var(--secondary-color);
        color: white;
      }

      #clearBtn {
        background-color: var(--warning-color);
        color: white;
      }

      #translateBtn {
        background-color: var(--success-color);
        color: white;
      }

      #exportBtn {
        background-color: #2196f3;
        color: white;
      }

      #importBtn {
        background-color: #607d8b;
        color: white;
      }

      #googleTranslateBtn {
        background-color: #4285f4;
        color: white;
      }

      #downloadAudioBtn {
        background-color: #9c27b0;
        color: white;
      }

      .status {
        text-align: center;
        margin: 12px 0;
        padding: 10px;
        border-radius: 8px;
        background-color: var(--light-color);
        font-size: 0.9rem;
      }

      .transcript-container {
        display: flex;
        flex-direction: column;
        gap: 15px;
        margin-top: 15px;
      }

      .text-display,
      .notes-display {
        width: 100%;
        min-height: 150px;
        padding: 12px;
        border-radius: 8px;
        background-color: #f9f9f9;
        border: 1px solid #ddd;
        font-size: 1rem;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
      }

      .notes-display {
        background-color: #fffde7;
      }

      .notes-list {
        list-style-type: none;
        padding: 0;
        margin: 0;
      }

      .note-item {
        padding: 12px;
        margin-bottom: 10px;
        background-color: #fff9c4;
        border-left: 4px solid #ffd600;
        border-radius: 6px;
        position: relative;
        word-break: break-word;
        transition: transform 0.2s ease;
      }

      .note-item .delete-note {
        position: absolute;
        right: 8px;
        top: 8px;
        background: var(--danger-color);
        color: white;
        border: none;
        border-radius: 50%;
        width: 24px;
        height: 24px;
        font-size: 14px;
        line-height: 24px;
        text-align: center;
        cursor: pointer;
        padding: 0;
        opacity: 0;
        transition: opacity var(--transition-speed);
      }

      .note-item:hover .delete-note {
        opacity: 1;
      }

      .settings {
        margin-top: 15px;
        padding: 12px;
        background-color: var(--light-color);
        border-radius: 8px;
        font-size: 0.9rem;
      }

      .translation-panel {
        margin-top: 15px;
        padding: 12px;
        background-color: #e3f2fd;
        border-radius: 8px;
      }

      .translation-result {
        margin-top: 10px;
        padding: 10px;
        background-color: #e8f5e9;
        border-radius: 8px;
        min-height: 60px;
        word-break: break-word;
      }

      select, input[type="range"] {
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #bdc3c7;
        width: 100%;
        margin-top: 8px;
        font-size: 0.9rem;
        background-color: white;
      }

      label {
        display: block;
        margin-bottom: 5px;
        font-weight: bold;
      }

      #targetLanguage {
        margin-top: 10px;
      }

      footer {
        text-align: center;
        margin-top: 20px;
        color: #7f8c8d;
        font-size: 0.8rem;
        padding: 10px;
      }

      .listening-indicator {
        display: inline-block;
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background-color: var(--success-color);
        margin-right: 8px;
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      .offline-status {
        position: fixed;
        bottom: 10px;
        left: 10px;
        padding: 5px 10px;
        background-color: var(--warning-color);
        color: white;
        border-radius: 3px;
        font-size: 12px;
        z-index: 1000;
      }

      .audio-controls {
        margin-top: 15px;
        padding: 12px;
        background-color: #f5f5f5;
        border-radius: 8px;
      }

      .audio-panel {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 10px;
      }

      #audioVisualizer {
        border-radius: 8px;
        overflow: hidden;
        width: 100%;
        height: 80px;
        background-color: #f0f0f0;
        margin-top: 10px;
      }

      .rtl-text {
        direction: rtl;
        text-align: right;
        font-family: var(--font-rtl);
      }

      .confidence-indicator {
        height: 4px;
        background-color: #e0e0e0;
        margin-top: 5px;
        border-radius: 2px;
        overflow: hidden;
      }

      .confidence-level {
        height: 100%;
        background-color: var(--success-color);
        width: 0%;
        transition: width 0.3s ease;
      }

      .export-dialog {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        width: 90%;
        max-width: 400px;
      }

      .export-dialog h3 {
        margin-top: 0;
        margin-bottom: 15px;
      }

      .export-dialog button {
        display: block;
        width: 100%;
        margin-bottom: 10px;
        padding: 12px;
      }

      .export-dialog button:last-child {
        margin-bottom: 0;
        background-color: #f5f5f5;
        color: #333;
      }

      .note-item.swiping {
        transition: none;
      }

      .translation-loading {
        display: inline-block;
        width: 16px;
        height: 16px;
        border: 2px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top-color: var(--success-color);
        animation: spin 1s ease-in-out infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .alert {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 10px 20px;
        border-radius: 5px;
        z-index: 1000;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
        color: white;
        animation: fadeIn 0.3s ease-out;
      }

      .alert-error {
        background-color: var(--danger-color);
      }

      .alert-warning {
        background-color: var(--warning-color);
      }

      .alert-success {
        background-color: var(--success-color);
      }

      .alert-info {
        background-color: var(--secondary-color);
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateX(-50%) translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateX(-50%) translateY(0);
        }
      }

      .icon {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      .install-btn {
        position: fixed;
        bottom: 20px;
        right: 20px;
        z-index: 1000;
        padding: 10px 15px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 5px;
        box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .progress-bar {
        height: 4px;
        background-color: rgba(255, 255, 255, 0.3);
        width: 100%;
        margin-top: 8px;
        border-radius: 2px;
        overflow: hidden;
      }

      .progress {
        height: 100%;
        background-color: var(--success-color);
        width: 0%;
        transition: width 0.3s ease;
      }

      @media (min-width: 768px) {
        .container {
          max-width: 900px;
          margin: 0 auto;
          padding: 25px;
          min-height: auto;
        }

        .transcript-container {
          flex-direction: row;
        }

        .text-display,
        .notes-display {
          min-height: 250px;
        }

        select {
          width: auto;
          margin-top: 0;
        }

        button {
          flex: 0 1 auto;
        }
      }

      @media (max-width: 360px) {
        button {
          padding: 10px 12px;
          font-size: 0.8rem;
        }
      }

      @media screen and (-webkit-min-device-pixel-ratio: 0) {
        select,
        textarea,
        input {
          font-size: 16px;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>Local Language Speech to Text</h1>

      <div class="android-message" id="androidStatus" style="display: none">
        <strong>Android App Status:</strong>
        <span id="androidStatusText">Initializing...</span>
      </div>

      <div class="android-message" id="androidWarning" style="display: none">
        <strong>Note for Android Users:</strong> For best results with local
        languages, use Chrome browser and ensure you have the language pack
        installed.
      </div>

      <div class="status" id="status">
        <span class="listening-indicator"></span>Auto-listening activated...
      </div>

      <div class="control-panel">
        <button id="toggleBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7,9.5V14.5H12V9.5H7M16,9.5V14.5H17V9.5H16Z" />
          </svg>
          Pause Listening
        </button>
        <button id="addNoteBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
          </svg>
          Add as Note
        </button>
        <button id="clearBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" />
          </svg>
          Clear All
        </button>
        <button id="exportBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
          </svg>
          Export Notes
        </button>
        <button id="importBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M5,20H19V18H5M19,9H15V3H9V9H5L12,16L19,9Z" />
          </svg>
          Import Notes
        </button>
        <button id="googleTranslateBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M12.87,15.07L10.33,12.56L10.36,12.53C12.1,10.59 13.34,8.36 14.07,6H17V4H10V2H8V4H1V6H12.17C11.5,7.92 10.44,9.75 9,11.35C8.07,10.32 7.3,9.19 6.69,8H4.69C5.42,9.63 6.42,11.17 7.67,12.56L2.58,17.58L4,19L9,14L12.11,17.11L12.87,15.07M18.5,10H16.5L12,22H14L15.12,19H19.87L21,22H23L18.5,10M15.88,17L17.5,12.67L19.12,17H15.88Z" />
          </svg>
          Google Translate
        </button>
        <button id="downloadAudioBtn" style="display: none">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M11,16.5L18,9.5L16.59,8.09L11,13.67L7.91,10.59L6.5,12L11,16.5Z" />
          </svg>
          Download Recording
        </button>
      </div>

      <div class="transcript-container">
        <div class="text-display" id="textDisplay" contenteditable="true" spellcheck="false">
          Your transcribed text will appear here...
        </div>

        <div class="notes-display">
          <h3>Your Notes</h3>
          <div class="progress-bar" id="storageUsageBar">
            <div class="progress" id="storageUsageProgress"></div>
          </div>
          <ul class="notes-list" id="notesList"></ul>
        </div>
      </div>

      <div class="settings">
        <label for="languageSelect">Speech Language:</label>
        <select id="languageSelect">
          <optgroup label="African Languages">
            <option value="am-ET">Amharic (አማርኛ)</option>
            <option value="ti-ET">Tigrinya (ትግርኛ)</option>
            <option value="om-ET">Oromo (Oromoo)</option>
            <option value="so-SO">Somali (Soomaali)</option>
            <option value="ha-NG">Hausa</option>
            <option value="sw-KE">Swahili</option>
          </optgroup>
          <optgroup label="European Languages">
            <option value="en-US" selected>English (US)</option>
            <option value="en-GB">English (UK)</option>
            <option value="es-ES">Spanish (Español)</option>
            <option value="fr-FR">French (Français)</option>
            <option value="de-DE">German (Deutsch)</option>
            <option value="it-IT">Italian (Italiano)</option>
            <option value="pt-BR">Portuguese (Português)</option>
            <option value="ru-RU">Russian (Русский)</option>
          </optgroup>
          <optgroup label="Asian Languages">
            <option value="ar-SA">Arabic (العربية)</option>
            <option value="fa-IR">Persian (فارسی)</option>
            <option value="hi-IN">Hindi (हिन्दी)</option>
            <option value="bn-IN">Bengali (বাংলা)</option>
            <option value="pa-IN">Punjabi (ਪੰਜਾਬੀ)</option>
            <option value="ja-JP">Japanese (日本語)</option>
            <option value="ko-KR">Korean (한국어)</option>
            <option value="zh-CN">Chinese (简体中文)</option>
            <option value="zh-TW">Chinese (繁體中文)</option>
          </optgroup>
          <optgroup label="Other Local Languages">
            <option value="zu-ZA">Zulu</option>
            <option value="xh-ZA">Xhosa</option>
            <option value="af-ZA">Afrikaans</option>
            <option value="ms-MY">Malay</option>
            <option value="id-ID">Indonesian</option>
            <option value="th-TH">Thai</option>
            <option value="vi-VN">Vietnamese</option>
          </optgroup>
        </select>

        <div class="confidence-indicator" id="confidenceIndicator">
          <div class="confidence-level" id="confidenceLevel"></div>
        </div>
      </div>

      <div class="translation-panel">
        <button id="translateBtn">
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M12.87,15.07L10.33,12.56L10.36,12.53C12.1,10.59 13.34,8.36 14.07,6H17V4H10V2H8V4H1V6H12.17C11.5,7.92 10.44,9.75 9,11.35C8.07,10.32 7.3,9.19 6.69,8H4.69C5.42,9.63 6.42,11.17 7.67,12.56L2.58,17.58L4,19L9,14L12.11,17.11L12.87,15.07M18.5,10H16.5L12,22H14L15.12,19H19.87L21,22H23L18.5,10M15.88,17L17.5,12.67L19.12,17H15.88Z" />
          </svg>
          Translate Text
        </button>
        <label for="targetLanguage">Target Language:</label>
        <select id="targetLanguage">
          <optgroup label="African Languages">
            <option value="am">Amharic</option>
            <option value="ti">Tigrinya</option>
            <option value="om">Oromo</option>
            <option value="so" selected>Somali</option>
            <option value="ha">Hausa</option>
            <option value="sw">Swahili</option>
          </optgroup>
          <optgroup label="European Languages">
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
            <option value="it">Italian</option>
            <option value="pt">Portuguese</option>
            <option value="ru">Russian</option>
          </optgroup>
          <optgroup label="Asian Languages">
            <option value="ar">Arabic</option>
            <option value="fa">Persian</option>
            <option value="hi">Hindi</option>
            <option value="bn">Bengali</option>
            <option value="pa">Punjabi</option>
            <option value="ja">Japanese</option>
            <option value="ko">Korean</option>
            <option value="zh">Chinese (Simplified)</option>
            <option value="zh-TW">Chinese (Traditional)</option>
          </optgroup>
        </select>
        <div class="translation-result" id="translationResult"></div>
      </div>

      <div class="audio-controls">
        <h3>Audio Settings</h3>
        <div class="audio-panel">
          <button id="startMicBtn">
            <svg class="icon" viewBox="0 0 24 24">
              <path d="M12,2A3,3 0 0,1 15,5V11A3,3 0 0,1 12,14A3,3 0 0,1 9,11V5A3,3 0 0,1 12,2M19,11C19,14.53 16.39,17.44 13,17.93V21H11V17.93C7.61,17.44 5,14.53 5,11H7A5,5 0 0,0 12,16A5,5 0 0,0 17,11H19Z" />
            </svg>
            Start Microphone
          </button>
          <button id="stopMicBtn" disabled>
            <svg class="icon" viewBox="0 0 24 24">
              <path d="M19,11C19,13.78 17.58,16.23 15.43,17.67L14,16.24C15.81,15.08 17,13.14 17,11H19M12,16.5L13.5,18H10.5L12,16.5M13.33,12.3L14.37,13.34C14.64,12.97 14.84,12.54 14.95,12.08L13.33,10.46V12.3M12,4A7,7 0 0,1 19,11H17A5,5 0 0,0 12,6A5,5 0 0,0 7,11H5A7,7 0 0,1 12,4M9,11C9,12.66 10.34,14 12,14C13.66,14 15,12.66 15,11V5C15,3.34 13.66,2 12,2C10.34,2 9,3.34 9,5V11M6.67,10.46L5.05,12.08C5.16,12.54 5.36,12.97 5.63,13.34L6.67,12.3V10.46M20,4L18.5,5.5L20,7L21.5,5.5L20,4M4,4L2.5,5.5L4,7L5.5,5.5L4,4M12,19A1,1 0 0,1 13,20A1,1 0 0,1 12,21A1,1 0 0,1 11,20A1,1 0 0,1 12,19Z" />
            </svg>
            Stop Microphone
          </button>
          <div style="flex: 1; min-width: 150px">
            <label for="volumeControl">Volume:</label>
            <input
              type="range"
              id="volumeControl"
              min="0"
              max="1"
              step="0.1"
              value="0.7"
              style="width: 100%"
            />
          </div>
        </div>
        <label for="audioInputSelect">Microphone Source:</label>
        <select id="audioInputSelect" style="width: 100%; margin-top: 8px">
          <option value="default">Default</option>
        </select>
        <div id="audioVisualizer"></div>
      </div>
    </div>
    <footer>
      Note: Speech recognition and translation require internet, but notes work
      offline.
    </footer>

    <div id="offlineIndicator" class="offline-status" style="display: none">
      OFFLINE MODE
    </div>

    <script>
      // Global variables
      let recognition;
      let isListening = false;
      let isAutoListening = true;
      let finalTranscript = "";
      let audioContext;
      let microphone;
      let analyser;
      let gainNode;
      let isMicActive = false;
      let mediaRecorder;
      let audioChunks = [];
      let audioBlob;
      let audioUrl;
      let touchStartX = 0;
      let touchEndX = 0;
      let lastConfidence = 0;
      let lastFinalTranscript = "";
      let db;
      const DB_NAME = "SpeechNotesDB";
      const DB_VERSION = 2;
      const STORE_NAME = "notes";
      const rtlLanguages = [
        "ar", "fa", "he", "ur", "ps", "ku", "sd", "dv", "yi", "ha"
      ];
      const translationCache = new Map();
      const MAX_STORAGE_QUOTA = 5 * 1024 * 1024; // 5MB

      // Audio processor worklet code
      const audioProcessorWorkletCode = `
        class AudioProcessor extends AudioWorkletProcessor {
          process(inputs, outputs) {
            const input = inputs[0];
            const output = outputs[0];
            
            for (let channel = 0; channel < input.length; ++channel) {
              output[channel].set(input[channel]);
            }
            
            return true;
          }
        }
        
        registerProcessor('audio-processor', AudioProcessor);
      `;

      // ========== INITIALIZATION FUNCTIONS ==========
      function isAndroid() {
        return /Android/i.test(navigator.userAgent);
      }

      function isAndroidApp() {
        const userAgent = navigator.userAgent;
        return /Android/i.test(userAgent) && /wv|webview/i.test(userAgent);
      }

      function isIOS() {
        return /iPhone|iPad|iPod/i.test(navigator.userAgent);
      }

      function setupAndroidApp() {
        if (!isAndroidApp()) return;

        const androidStatus = document.getElementById("androidStatus");
        const androidStatusText = document.getElementById("androidStatusText");
        androidStatus.style.display = "block";

        const hasRequiredFeatures =
          "webkitSpeechRecognition" in window &&
          "indexedDB" in window &&
          "serviceWorker" in navigator;

        if (!hasRequiredFeatures) {
          androidStatusText.textContent = "WebView missing required features";
          androidStatus.style.backgroundColor = "#ffebee";
          return;
        }

        try {
          androidStatusText.textContent = "Initializing for Android...";

          if (window.AndroidInterface?.requestMicrophonePermission) {
            window.AndroidInterface.requestMicrophonePermission()
              .then(() => {
                androidStatusText.textContent = "Microphone permission granted";
                initRecognitionForAndroid();
              })
              .catch((err) => {
                androidStatusText.textContent = "Microphone permission denied";
                console.error("Android permission error:", err);
              });
          } else {
            androidStatusText.textContent = "Using browser permissions";
            initRecognitionForAndroid();
          }
        } catch (error) {
          androidStatusText.textContent = `Initialization failed: ${error.message}`;
          console.error("Android setup error:", error);
        }
      }

      function initRecognitionForAndroid() {
        const SpeechRecognition =
          window.SpeechRecognition || window.webkitSpeechRecognition;

        if (!SpeechRecognition) {
          showAlert(
            "Speech recognition not supported in this WebView",
            "error"
          );
          return;
        }

        recognition = new SpeechRecognition();
        recognition.continuous = true;
        recognition.interimResults = true;
        recognition.maxAlternatives = 1;
        recognition.lang = document.getElementById("languageSelect").value;

        if (navigator.userAgent.match(/Android\s([0-9\.]+)/)) {
          const androidVersion = parseFloat(RegExp.$1);
          if (androidVersion < 8) {
            recognition.interimResults = false;
          }
        }

        recognition.onerror = function (event) {
          let errorMessage = "Recognition error";

          switch (event.error) {
            case "no-speech":
              errorMessage = "No speech detected - try speaking louder";
              break;
            case "audio-capture":
              errorMessage = "Microphone not available";
              initAudioContext().then(() => recognition.start());
              break;
            case "not-allowed":
              errorMessage = "Microphone access denied - check app permissions";
              break;
            default:
              errorMessage = `Error: ${event.error}`;
          }

          showAlert(errorMessage, "error");

          const retryDelay = Math.min(
            5000,
            (this.retryCount || 0) * 1000 + 1000
          );
          setTimeout(() => {
            if (isAutoListening) {
              this.retryCount = (this.retryCount || 0) + 1;
              recognition.start();
            }
          }, retryDelay);
        };

        recognition.onresult = function (event) {
          let interimTranscript = "";
          let newFinalTranscript = "";
          const isAndroidDevice = isAndroid();

          for (let i = event.resultIndex; i < event.results.length; i++) {
            const result = event.results[i];
            const transcript = result[0].transcript;
            const confidence = result[0].confidence || 0;

            if (result.isFinal) {
              const trimmedTranscript = transcript.trim();
              if (
                !isAndroidDevice ||
                !lastFinalTranscript.includes(trimmedTranscript)
              ) {
                newFinalTranscript += transcript + " ";
                lastFinalTranscript = newFinalTranscript;
              }
            } else {
              interimTranscript = transcript;
            }

            if (confidence > lastConfidence) {
              lastConfidence = confidence;
              updateConfidenceIndicator(confidence);
            }
          }

          if (newFinalTranscript) {
            finalTranscript += newFinalTranscript;
          }

          updateTextDisplay(finalTranscript, interimTranscript);
        };

        recognition.onend = function () {
          if (isAutoListening) {
            const delay = isAndroid() ? 200 : 50;
            setTimeout(() => {
              try {
                recognition.start();
              } catch (e) {
                console.log("Auto-restart failed, retrying...", e);
                setTimeout(() => {
                  if (isAutoListening) recognition.start();
                }, delay * 2);
              }
            }, delay);
          }
        };

        recognition.onstart = function () {
          isListening = true;
          document.getElementById("status").innerHTML =
            '<span class="listening-indicator"></span>Listening... Speak now!';
          document.getElementById("status").style.backgroundColor = "#e8f5e9";
          document.getElementById("toggleBtn").textContent = "Pause Listening";
          updateConfidenceIndicator(0);
        };

        setTimeout(() => {
          try {
            recognition.start();
          } catch (e) {
            console.error("Android recognition start error:", e);
            setTimeout(() => recognition.start(), 1000);
          }
        }, 300);
      }

      // ========== CORE FUNCTIONS ==========
      async function initAudioContext() {
        try {
          if (audioContext?.state === "suspended") {
            await audioContext.resume();
            return true;
          }

          audioContext = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: "interactive",
            sampleRate: 16000,
          });

          if (isAndroid()) {
            const buffer = audioContext.createBuffer(
              1,
              1,
              audioContext.sampleRate
            );
            const source = audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(audioContext.destination);
            source.start(0);

            setTimeout(() => {
              if (audioContext.state === "suspended") {
                audioContext.resume();
              }
            }, 200);
          }

          return true;
        } catch (error) {
          console.error("Audio context error:", error);
          showAlert("Audio initialization failed", "error");
          return false;
        }
      }

      function updateTextDisplay(final, interim) {
        if ("requestIdleCallback" in window) {
          requestIdleCallback(
            () => updateTextDisplayImmediately(final, interim),
            { timeout: 100 }
          );
        } else {
          requestAnimationFrame(() =>
            updateTextDisplayImmediately(final, interim)
          );
        }
      }

      function updateTextDisplayImmediately(final, interim) {
        const textDisplay = document.getElementById("textDisplay");
        if (!final && !interim) return;

        const newContent =
          final +
          (interim ? '<span style="color:#aaa;">' + interim + "</span>" : "");

        if (!interim) {
          textDisplay.textContent = newContent;
        } else {
          textDisplay.innerHTML = newContent;
        }

        applyTextDirection(
          textDisplay,
          document.getElementById("languageSelect").value
        );
      }

      function applyTextDirection(element, languageCode) {
        const baseLang = languageCode.split("-")[0];
        if (rtlLanguages.includes(baseLang)) {
          element.classList.add("rtl-text");
        } else {
          element.classList.remove("rtl-text");
        }
      }

      function updateConfidenceIndicator(confidence) {
        const confidenceLevel = document.getElementById("confidenceLevel");
        if (confidenceLevel) {
          const percentage = Math.round(confidence * 100);
          confidenceLevel.style.width = `${percentage}%`;

          if (percentage > 80) {
            confidenceLevel.style.backgroundColor = "var(--success-color)";
          } else if (percentage > 50) {
            confidenceLevel.style.backgroundColor = "var(--warning-color)";
          } else {
            confidenceLevel.style.backgroundColor = "var(--danger-color)";
          }
        }
      }

      function showAlert(message, type = "info") {
        const colors = {
          info: "#3498db",
          warning: "#f39c12",
          error: "#e74c3c",
          success: "#2ecc71",
        };

        const alertDiv = document.createElement("div");
        alertDiv.className = `alert alert-${type}`;
        alertDiv.textContent = message;

        document.body.appendChild(alertDiv);

        setTimeout(() => {
          alertDiv.style.opacity = "0";
          setTimeout(() => document.body.removeChild(alertDiv), 300);
        }, 3000);
      }

      // ========== DATABASE FUNCTIONS ==========
      function initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(DB_NAME, DB_VERSION);

          request.onerror = (event) => {
            console.error("Database error:", event.target.error);
            reject("Database error.");
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
              const store = db.createObjectStore(STORE_NAME, {
                keyPath: "id",
                autoIncrement: true,
              });
              store.createIndex("timestamp", "timestamp", { unique: false });
              store.createIndex("language", "language", { unique: false });
            }
          };

          request.onsuccess = (event) => {
            db = event.target.result;
            updateStorageUsage();
            resolve(db);
          };
        });
      }

      async function saveNoteToDB(text, language) {
        if (!db) await initDB();

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);

          const request = store.add({
            text: text,
            language: language,
            timestamp: new Date().toISOString(),
          });

          request.onsuccess = () => {
            updateStorageUsage();
            resolve(request.result);
          };
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function getAllNotesFromDB() {
        if (!db) await initDB();

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.getAll();

          request.onsuccess = () => resolve(request.result);
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function deleteNoteFromDB(id) {
        if (!db) await initDB();

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.delete(id);

          request.onsuccess = () => {
            updateStorageUsage();
            resolve(true);
          };
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function clearAllNotesFromDB() {
        if (!db) await initDB();

        return new Promise((resolve, reject) => {
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          const request = store.clear();

          request.onsuccess = () => {
            updateStorageUsage();
            resolve(true);
          };
          request.onerror = (event) => reject(event.target.error);
        });
      }

      async function updateStorageUsage() {
        if (!db) return;
        
        try {
          const notes = await getAllNotesFromDB();
          const totalSize = JSON.stringify(notes).length;
          const percentage = Math.min(100, (totalSize / MAX_STORAGE_QUOTA) * 100);
          
          const progressBar = document.getElementById("storageUsageProgress");
          if (progressBar) {
            progressBar.style.width = `${percentage}%`;
            
            if (percentage > 90) {
              progressBar.style.backgroundColor = "var(--danger-color)";
              showAlert("Storage almost full - consider exporting notes", "warning");
            } else if (percentage > 70) {
              progressBar.style.backgroundColor = "var(--warning-color)";
            } else {
              progressBar.style.backgroundColor = "var(--success-color)";
            }
          }
        } catch (error) {
          console.error("Error calculating storage usage:", error);
        }
      }

      // ========== EXPORT/IMPORT FUNCTIONS ==========
      async function exportAsDocx(notes) {
        try {
          const { default: docx } = await import(
            "https://cdn.jsdelivr.net/npm/docx@7.8.2/+esm"
          );
          const { Document, Paragraph, TextRun, Packer } = docx;

          const doc = new Document({
            sections: [
              {
                properties: {},
                children: [
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: "Speech to Text Notes Export",
                        bold: true,
                        size: 28,
                      }),
                    ],
                  }),
                  new Paragraph({
                    children: [
                      new TextRun({
                        text: `Exported on: ${new Date().toLocaleString()}`,
                        size: 22,
                        color: "666666",
                      }),
                    ],
                  }),
                  new Paragraph({ text: "" }),
                  ...notes.flatMap((note) => [
                    new Paragraph({
                      children: [
                        new TextRun({
                          text: note.text,
                          size: 24,
                          rightToLeft: rtlLanguages.includes(
                            note.language?.split("-")[0]
                          ),
                        }),
                      ],
                    }),
                    new Paragraph({ text: "" }),
                  ]),
                ],
              },
            ],
          });

          const blob = await Packer.toBlob(doc);
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `speech-notes-${new Date().toISOString().split('T')[0]}.docx`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("Error generating Word document:", error);
          showAlert("Failed to export as Word document.", "error");
        }
      }

      async function exportAsTxt(notes) {
        try {
          const textContent = notes.map((note) => note.text).join("\n\n");
          const blob = new Blob([textContent], { type: "text/plain" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = `speech-notes-${new Date().toISOString().split('T')[0]}.txt`;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        } catch (error) {
          console.error("Error generating TXT file:", error);
          showAlert("Failed to export as TXT file.", "error");
        }
      }

      async function importDocxFile(file) {
        try {
          const { default: mammoth } = await import(
            "https://cdn.jsdelivr.net/npm/mammoth@1.4.0/+esm"
          );

          const arrayBuffer = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (event) => resolve(event.target.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
          });

          const result = await mammoth.extractRawText({ arrayBuffer });
          const text = result.value;

          return text
            .split("\n")
            .map((line) => line.trim())
            .filter((line) => line.length > 0)
            .map((line) => ({ text: line }));
        } catch (error) {
          console.error("Error reading Word document:", error);
          throw new Error("Could not read Word document.");
        }
      }

      // ========== TRANSLATION FUNCTIONS ==========
      async function translateText(text, targetLang) {
        if (!text?.trim()) {
          console.error("Invalid text for translation");
          return "";
        }

        // Check cache first
        const cacheKey = `${text}-${targetLang}`;
        if (translationCache.has(cacheKey)) {
          return translationCache.get(cacheKey);
        }

        // Validate target language
        const validLangs = [
          ...document.getElementById("targetLanguage").options,
        ].map((opt) => opt.value);
        if (!validLangs.includes(targetLang)) {
          console.error(`Invalid target language: ${targetLang}`);
          return text;
        }

        try {
          // Try LibreTranslate first
          const libreResult = await translateWithLibre(text, targetLang);
          if (libreResult) {
            translationCache.set(cacheKey, libreResult);
            return libreResult;
          }

          // Fallback to MyMemory
          const myMemoryResult = await translateWithMyMemory(text, targetLang);
          if (myMemoryResult) {
            translationCache.set(cacheKey, myMemoryResult);
            return myMemoryResult;
          }

          // Final fallback
          const fallback = localFallbackTranslation(text, targetLang);
          translationCache.set(cacheKey, fallback);
          return fallback;
        } catch (error) {
          console.error("Translation error:", error);
          const fallback = localFallbackTranslation(text, targetLang);
          translationCache.set(cacheKey, fallback);
          return fallback;
        }
      }

      async function translateWithLibre(text, targetLang) {
        try {
          const response = await fetch("https://libretranslate.com/translate", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              q: text,
              source: "auto",
              target: targetLang,
              format: "text",
            }),
            timeout: 5000,
          });

          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

          const data = await response.json();
          return data.translatedText || null;
        } catch (error) {
          console.warn("LibreTranslate failed:", error.message);
          return null;
        }
      }

      async function translateWithMyMemory(text, targetLang) {
        try {
          const MAX_CHUNK_SIZE = 4000;
          const chunks = [];

          for (let i = 0; i < text.length; i += MAX_CHUNK_SIZE) {
            chunks.push(text.substring(i, i + MAX_CHUNK_SIZE));
          }

          const translatedChunks = await Promise.all(
            chunks.map((chunk) => translateMyMemoryChunk(chunk, targetLang))
          );

          return translatedChunks.join(" ");
        } catch (error) {
          console.warn("MyMemory translation failed:", error.message);
          return null;
        }
      }

      async function translateMyMemoryChunk(chunk, targetLang) {
        const response = await fetch(
          `https://api.mymemory.translated.net/get?q=${encodeURIComponent(
            chunk
          )}&langpair=auto|${targetLang}`
        );

        if (!response.ok)
          throw new Error(`HTTP error! status: ${response.status}`);

        const data = await response.json();
        return data.responseData?.translatedText || chunk;
      }

      function localFallbackTranslation(text, targetLang) {
        const translations = {
          en: {
            hello: "hello",
            "thank you": "thank you",
            goodbye: "goodbye",
            "how are you": "how are you",
            "what is your name": "what is your name",
            yes: "yes",
            no: "no",
            please: "please",
            help: "help",
          },
          es: {
            hello: "hola",
            "thank you": "gracias",
            goodbye: "adiós",
            "how are you": "cómo estás",
            "what is your name": "cómo te llamas",
            yes: "sí",
            no: "no",
            please: "por favor",
            help: "ayuda",
          },
          so: {
            hello: "salaam",
            "thank you": "mahadsanid",
            goodbye: "nabad gelyo",
            "how are you": "sidee tahay",
            "what is your name": "magacaa",
            yes: "haa",
            no: "maya",
            please: "fadlan",
            help: "caawi",
          },
          fr: {
            hello: "bonjour",
            "thank you": "merci",
            goodbye: "au revoir",
            "how are you": "comment ça va",
            "what is your name": "comment tu t'appelles",
            yes: "oui",
            no: "non",
            please: "s'il vous plaît",
            help: "aider",
          },
        };

        const langCode = targetLang.split("-")[0];
        const lowerText = text.toLowerCase().trim();

        if (translations[langCode]?.[lowerText]) {
          return translations[langCode][lowerText];
        }

        const words = lowerText.split(/\s+/);
        if (words.length <= 3) {
          const translated = words
            .map((word) => translations[langCode]?.[word] || word)
            .join(" ");
          if (translated !== lowerText) return translated;
        }

        return `${text} [Translation failed for ${targetLang}]`;
      }

      function openGoogleTranslate(text, sourceLang, targetLang) {
        const langMap = {
          am: "am",
          ti: "ti",
          om: "om",
          so: "so",
          ha: "ha",
          sw: "sw",
          en: "en",
          es: "es",
          fr: "fr",
          de: "de",
          it: "it",
          pt: "pt",
          ru: "ru",
          ar: "ar",
          fa: "fa",
          hi: "hi",
          bn: "bn",
          pa: "pa",
          ja: "ja",
          ko: "ko",
          zh: "zh-CN",
          "zh-TW": "zh-TW",
        };

        const sourceCode = langMap[sourceLang.split("-")[0]] || "auto";
        const targetCode = langMap[targetLang] || "en";

        const url = `https://translate.google.com/?sl=${sourceCode}&tl=${targetCode}&text=${encodeURIComponent(
          text
        )}&op=translate`;
        window.open(url, "_blank");
      }

      // ========== MAIN INITIALIZATION ==========
      document.addEventListener("DOMContentLoaded", async function () {
        const textDisplay = document.getElementById("textDisplay");
        const notesList = document.getElementById("notesList");
        const toggleBtn = document.getElementById("toggleBtn");
        const addNoteBtn = document.getElementById("addNoteBtn");
        const clearBtn = document.getElementById("clearBtn");
        const exportBtn = document.getElementById("exportBtn");
        const importBtn = document.getElementById("importBtn");
        const googleTranslateBtn = document.getElementById("googleTranslateBtn");
        const downloadAudioBtn = document.getElementById("downloadAudioBtn");
        const status = document.getElementById("status");
        const languageSelect = document.getElementById("languageSelect");
        const translateBtn = document.getElementById("translateBtn");
        const targetLanguage = document.getElementById("targetLanguage");
        const translationResult = document.getElementById("translationResult");
        const startMicBtn = document.getElementById("startMicBtn");
        const stopMicBtn = document.getElementById("stopMicBtn");
        const volumeControl = document.getElementById("volumeControl");
        const audioVisualizer = document.getElementById("audioVisualizer");
        const androidWarning = document.getElementById("androidWarning");
        const audioInputSelect = document.getElementById("audioInputSelect");
        const androidStatus = document.getElementById("androidStatus");
        const androidStatusText = document.getElementById("androidStatusText");

        // Auto-save draft functionality
        let draftTimer;
        textDisplay.addEventListener("input", () => {
          clearTimeout(draftTimer);
          draftTimer = setTimeout(() => {
            localStorage.setItem("speechDraft", textDisplay.textContent);
          }, 5000);
        });

        // Restore draft on load
        window.addEventListener("load", () => {
          const draft = localStorage.getItem("speechDraft");
          if (draft) {
            textDisplay.textContent = draft;
            showAlert("Restored unsaved draft", "success");
          }
        });

        // Show Android-specific instructions
        if (isAndroid()) {
          androidWarning.style.display = "block";
          if (!/Chrome/i.test(navigator.userAgent)) {
            androidWarning.innerHTML +=
              "<br><br><strong>Recommendation:</strong> For best local language support, please use Google Chrome browser.";
          }

          const androidTips = document.createElement("div");
          androidTips.className = "android-message";
          androidTips.innerHTML = `
            <strong>Android Tips:</strong>
            <ul>
              <li>Hold device closer when speaking for better accuracy</li>
              <li>Use headphones with microphone in noisy environments</li>
              <li>Close other apps to free up system resources</li>
            </ul>
          `;
          document
            .querySelector(".container")
            .insertBefore(androidTips, document.querySelector(".status"));
        } else {
          androidWarning.style.display = "none";
        }

        // Show iOS-specific instructions
        if (isIOS()) {
          const iosMessage = document.createElement("div");
          iosMessage.className = "info-message";
          iosMessage.innerHTML = `
            <strong>iOS Users:</strong> For best results, use Safari browser and ensure microphone permissions are granted.
          `;
          document
            .querySelector(".container")
            .insertBefore(iosMessage, document.querySelector(".status"));
        }

        // Initialize database.
        try {
          await initDB();
          // Load existing notes.
          const notes = await getAllNotesFromDB();
          notes.forEach((note) => {
            addNoteToUI(note.text, note.id, note.language);
          });
        } catch (error) {
          console.error("Failed to initialize database:", error);
          showAlert("Failed to load notes from storage", "error");
        }

        // Check for browser support.
        if (
          !("webkitSpeechRecognition" in window) &&
          !("SpeechRecognition" in window)
        ) {
          status.innerHTML =
            '<span style="color:red;">Speech recognition not supported in your browser. Try Chrome or Edge.</span>';
          toggleBtn.disabled = true;
          addNoteBtn.disabled = true;
          return;
        }

        // Initialize recognition differently for Android
        if (isAndroidApp()) {
          setupAndroidApp();
        } else {
          // Standard initialization for non-Android
          const SpeechRecognition =
            window.SpeechRecognition || window.webkitSpeechRecognition;
          recognition = new SpeechRecognition();

          recognition.continuous = true;
          recognition.interimResults = true;
          recognition.maxAlternatives = 1;
          recognition.lang = languageSelect.value;

          recognition.onresult = function (event) {
            let interimTranscript = "";
            let newFinalTranscript = "";

            for (let i = event.resultIndex; i < event.results.length; i++) {
              const result = event.results[i];
              const transcript = result[0].transcript;
              const confidence = result[0].confidence || 0;

              if (result.isFinal) {
                newFinalTranscript += transcript + " ";
                lastFinalTranscript = newFinalTranscript;
              } else {
                interimTranscript = transcript;
              }

              if (confidence > lastConfidence) {
                lastConfidence = confidence;
                updateConfidenceIndicator(confidence);
              }
            }

            if (newFinalTranscript) {
              finalTranscript += newFinalTranscript;
            }

            updateTextDisplay(finalTranscript, interimTranscript);
          };

          recognition.onend = function () {
            if (isAutoListening) {
              setTimeout(() => {
                try {
                  recognition.start();
                } catch (e) {
                  console.log("Auto-restart failed, retrying...", e);
                  setTimeout(() => {
                    if (isAutoListening) recognition.start();
                  }, 100);
                }
              }, 50);
            }
          };

          recognition.onstart = function () {
            isListening = true;
            status.innerHTML =
              '<span class="listening-indicator"></span>Listening... Speak now!';
            status.style.backgroundColor = "#e8f5e9";
            toggleBtn.textContent = "Pause Listening";
            updateConfidenceIndicator(0);
          };

          recognition.onerror = function (event) {
            console.error("Recognition error:", event.error);
            isListening = false;

            let errorMessage = "Error occurred.";
            switch (event.error) {
              case "no-speech":
                errorMessage = "No speech detected.";
                break;
              case "audio-capture":
                errorMessage = "Microphone not available.";
                break;
              case "not-allowed":
                errorMessage = "Microphone access denied.";
                break;
              case "service-not-allowed":
                errorMessage = "Speech recognition service not allowed.";
                break;
              case "network":
                errorMessage = "Network error occurred.";
                break;
              case "language-not-supported":
                errorMessage =
                  "Selected language not supported on this device.";
                break;
              default:
                errorMessage = `Error: ${event.error}`;
            }

            status.innerHTML = `<span style="color:red;">${errorMessage}</span>`;
            status.style.backgroundColor = "#ffebee";
            toggleBtn.textContent = "Start Listening";
            updateConfidenceIndicator(0);

            let retryDelay = 500;
            if (event.error === "no-speech") retryDelay = 1000;
            else if (event.error === "network") retryDelay = 2000;
            else if (event.error === "language-not-supported")
              retryDelay = 1500;

            setTimeout(() => {
              if (isAutoListening) recognition.start();
            }, retryDelay);
          };

          async function setInitialLanguage() {
            const userLang = navigator.language || "en-US";
            const availableLangs = Array.from(languageSelect.options).map(
              (opt) => opt.value
            );

            const supportedLangs = [];
            for (const lang of availableLangs) {
              const isSupported = await checkLanguageSupport(lang);
              if (isSupported) {
                supportedLangs.push(lang);
              }
            }

            let selectedLang = "en-US";
            if (supportedLangs.includes(userLang)) {
              selectedLang = userLang;
            } else {
              const baseLang = userLang.split("-")[0];
              const matchingLang = supportedLangs.find((lang) =>
                lang.startsWith(baseLang)
              );
              if (matchingLang) {
                selectedLang = matchingLang;
              } else if (supportedLangs.length > 0) {
                selectedLang = supportedLangs[0];
              }
            }

            languageSelect.value = selectedLang;
            recognition.lang = selectedLang;
            applyTextDirection(textDisplay, selectedLang);

            Array.from(languageSelect.options).forEach((option) => {
              option.disabled = !supportedLangs.includes(option.value);
            });
          }

          async function checkLanguageSupport(languageCode) {
            if (!("webkitSpeechRecognition" in window)) return false;

            const tempRecognition = new (window.SpeechRecognition ||
              window.webkitSpeechRecognition)();
            tempRecognition.lang = languageCode;

            return new Promise((resolve) => {
              let timeoutId;

              tempRecognition.onerror = (event) => {
                clearTimeout(timeoutId);
                resolve(event.error !== "language-not-supported");
              };

              tempRecognition.onstart = () => {
                clearTimeout(timeoutId);
                tempRecognition.stop();
                resolve(true);
              };

              tempRecognition.onend = () => {
                clearTimeout(timeoutId);
                resolve(true);
              };

              timeoutId = setTimeout(() => {
                tempRecognition.stop();
                resolve(false);
              }, 1000);

              tempRecognition.start();
            });
          }

          await setInitialLanguage();

          if (navigator.onLine) {
            setTimeout(() => {
              try {
                recognition.start();
              } catch (e) {
                console.log("Initial start failed, retrying...", e);
                setTimeout(() => {
                  try {
                    recognition.start();
                  } catch (e2) {
                    console.log("Second attempt failed:", e2);
                    status.innerHTML =
                      '<span style="color:red;">Microphone error. Refresh and allow access.</span>';
                  }
                }, 300);
              }
            }, 100);
          }
        }

        // Populate audio input devices dropdown
        async function updateAudioInputs() {
          try {
            const devices = await navigator.mediaDevices.enumerateDevices();
            const audioInputs = devices.filter(
              (device) => device.kind === "audioinput"
            );

            while (audioInputSelect.options.length > 1) {
              audioInputSelect.remove(1);
            }

            audioInputs.forEach((device) => {
              const option = document.createElement("option");
              option.value = device.deviceId;
              option.text =
                device.label || `Microphone ${audioInputSelect.options.length}`;
              audioInputSelect.appendChild(option);
            });
          } catch (err) {
            console.error("Error enumerating devices:", err);
          }
        }

        updateAudioInputs();
        navigator.mediaDevices.addEventListener(
          "devicechange",
          updateAudioInputs
        );

        // Start microphone with proper error handling.
        startMicBtn.addEventListener("click", async function () {
          try {
            // First stop any existing microphone
            if (isMicActive) {
              if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
              }
              if (microphone) microphone.disconnect();
            }

            // Initialize audio context if needed
            if (!audioContext && !(await initAudioContext())) {
              return;
            }

            // Get selected device ID
            const deviceId =
              audioInputSelect.value === "default"
                ? undefined
                : audioInputSelect.value;

            // Get user media with better device handling
            const stream = await navigator.mediaDevices.getUserMedia({
              audio: {
                deviceId: deviceId,
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: true,
                channelCount: 1,
              },
              video: false,
            });

            // Create nodes.
            gainNode = audioContext.createGain();
            gainNode.gain.value = volumeControl.value;

            analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;

            // Create source and connect nodes.
            microphone = audioContext.createMediaStreamSource(stream);

            // Add audio processing for better headset compatibility
            if (audioContext.createAudioWorklet) {
              try {
                // Create a blob URL for the audio processor worklet
                const blob = new Blob([audioProcessorWorkletCode], {
                  type: "application/javascript",
                });
                const url = URL.createObjectURL(blob);

                await audioContext.audioWorklet.addModule(url);
                const workletNode = new AudioWorkletNode(
                  audioContext,
                  "audio-processor"
                );
                microphone.connect(workletNode);
                workletNode.connect(analyser);
              } catch (e) {
                console.warn(
                  "AudioWorklet not available, using script processor"
                );
                const scriptNode = audioContext.createScriptProcessor(
                  4096,
                  1,
                  1
                );
                microphone.connect(scriptNode);
                scriptNode.connect(analyser);
              }
            } else {
              microphone.connect(gainNode);
              gainNode.connect(analyser);
            }

            analyser.connect(audioContext.destination);

            // Setup visualization.
            setupVisualizer();

            // Setup recording.
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];

            mediaRecorder.ondataavailable = function (e) {
              if (e.data.size > 0) {
                audioChunks.push(e.data);
              }
            };

            mediaRecorder.onstop = function () {
              audioBlob = new Blob(audioChunks, { type: "audio/wav" });
              audioUrl = URL.createObjectURL(audioBlob);
              downloadAudioBtn.style.display = "block";
            };

            mediaRecorder.start(100); // Collect 100ms chunks.
            isMicActive = true;

            // Update UI.
            startMicBtn.disabled = true;
            stopMicBtn.disabled = false;
            status.innerHTML =
              '<span class="listening-indicator"></span>Microphone active - recording audio.';
          } catch (error) {
            console.error("Microphone error:", error);
            status.innerHTML = `<span style="color:red;">Microphone error: ${error.message}</span>`;
            showAlert("Failed to access microphone. Please check permissions.", "error");
          }
        });

        // Stop microphone properly.
        stopMicBtn.addEventListener("click", function () {
          if (!isMicActive) return;

          try {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
              mediaRecorder.stop();
            }

            // Disconnect all nodes.
            if (microphone) microphone.disconnect();
            if (gainNode) gainNode.disconnect();
            if (analyser) analyser.disconnect();

            isMicActive = false;
            startMicBtn.disabled = false;
            stopMicBtn.disabled = true;
            status.innerHTML = "Microphone stopped.";
          } catch (err) {
            console.error("Error stopping microphone:", err);
          }
        });

        // Download audio recording
        downloadAudioBtn.addEventListener("click", function () {
          if (audioUrl) {
            const a = document.createElement("a");
            a.href = audioUrl;
            a.download = `recording-${new Date().toISOString().replace(/[:.]/g, '-')}.wav`;
            a.click();
          }
        });

        // Volume control.
        volumeControl.addEventListener("input", function () {
          if (gainNode) {
            gainNode.gain.value = this.value;
          }
        });

        // Visualizer with proper animation frame handling.
        function setupVisualizer() {
          const canvas = document.createElement("canvas");
          canvas.width = audioVisualizer.offsetWidth;
          canvas.height = audioVisualizer.offsetHeight;
          audioVisualizer.innerHTML = "";
          audioVisualizer.appendChild(canvas);

          const canvasCtx = canvas.getContext("2d");
          const bufferLength = analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          let animationId;

          function draw() {
            if (!isMicActive) {
              cancelAnimationFrame(animationId);
              return;
            }

            animationId = requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);

            canvasCtx.fillStyle = "rgb(200, 200, 200)";
            canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = (canvas.width / bufferLength) * 2.5;
            let x = 0;

            for (let i = 0; i < bufferLength; i++) {
              const barHeight = dataArray[i] / 2;
              const hue = (i / bufferLength) * 360;

              canvasCtx.fillStyle = `hsl(${hue}, 100%, 50%)`;
              canvasCtx.fillRect(
                x,
                canvas.height - barHeight,
                barWidth,
                barHeight
              );

              x += barWidth + 1;
            }
          }

          draw();
        }

        // Handle window resize.
        window.addEventListener("resize", function () {
          if (isMicActive) {
            setupVisualizer();
          }
        });

        // Button event listeners.
        toggleBtn.addEventListener("click", function () {
          this.disabled = true;

          if (isListening) {
            // Pause listening.
            isAutoListening = false;
            try {
              recognition.stop();
            } catch (e) {
              console.log("Error stopping recognition:", e);
            }
            isListening = false;
            toggleBtn.textContent = "Start Listening";
            status.textContent = "Listening paused.";
            status.style.backgroundColor = "#fff3e0";
          } else {
            // Start listening.
            isAutoListening = true;
            recognition.lang = languageSelect.value;
            try {
              recognition.start();
            } catch (e) {
              console.log("Error starting recognition:", e);
              status.innerHTML =
                '<span style="color:red;">Error starting microphone. Please refresh and allow permissions.</span>';
              setTimeout(() => {
                if (isAutoListening) recognition.start();
              }, 300);
            }
          }

          setTimeout(() => {
            this.disabled = false;
          }, 300);
        });

        addNoteBtn.addEventListener("click", async function () {
          if (
            textDisplay.textContent.trim() &&
            textDisplay.textContent.trim() !==
              "Your transcribed text will appear here..."
          ) {
            const noteText = textDisplay.textContent.trim();
            const currentLanguage = languageSelect.value;
            try {
              const noteId = await saveNoteToDB(noteText, currentLanguage);
              addNoteToUI(noteText, noteId, currentLanguage);
              textDisplay.textContent = "";
              finalTranscript = "";
              lastFinalTranscript = "";
              localStorage.removeItem("speechDraft");
              showAlert("Note saved successfully", "success");
            } catch (error) {
              console.error("Failed to save note:", error);
              addNoteToUI(noteText, null, currentLanguage);
              textDisplay.textContent = "";
              finalTranscript = "";
              lastFinalTranscript = "";
              localStorage.removeItem("speechDraft");
              showAlert("Note saved locally (not synced to storage)", "warning");
            }
          } else {
            showAlert("No text to save as note", "warning");
          }
        });

        clearBtn.addEventListener("click", async function () {
          if (confirm("Are you sure you want to clear all notes? This cannot be undone.")) {
            textDisplay.textContent = "";
            notesList.innerHTML = "";
            finalTranscript = "";
            lastFinalTranscript = "";
            try {
              await clearAllNotesFromDB();
              localStorage.removeItem("speechDraft");
              showAlert("All notes cleared", "success");
            } catch (error) {
              console.error("Failed to clear notes:", error);
              showAlert("Failed to clear notes from storage", "error");
            }
          }
        });

        // Google Translate button event listener
        googleTranslateBtn.addEventListener("click", function () {
          const textToTranslate = textDisplay.textContent.trim();

          if (
            !textToTranslate ||
            textToTranslate === "Your transcribed text will appear here..."
          ) {
            showAlert("Please enter some text to translate", "warning");
            return;
          }

          const sourceLang = languageSelect.value;
          const targetLang = targetLanguage.value;

          openGoogleTranslate(textToTranslate, sourceLang, targetLang);
        });

        // Updated export button with dialog
        exportBtn.addEventListener("click", async function () {
          try {
            const notes = await getAllNotesFromDB();
            if (notes.length === 0) {
              showAlert("No notes to export", "warning");
              return;
            }

            // Create export dialog
            const exportDialog = document.createElement("div");
            exportDialog.className = "export-dialog";
            exportDialog.innerHTML = `
              <h3>Export Options</h3>
              <button id="exportDocx">
                <svg class="icon" viewBox="0 0 24 24">
                  <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                </svg>
                Export as Word Document (.docx)
              </button>
              <button id="exportTxt">
                <svg class="icon" viewBox="0 0 24 24">
                  <path d="M14,2H6A2,2 0 0,0 4,4V20A2,2 0 0,0 6,22H18A2,2 0 0,0 20,20V8L14,2M18,20H6V4H13V9H18V20Z" />
                </svg>
                Export as Text File (.txt)
              </button>
              <button id="exportCancel">Cancel</button>
            `;

            document.body.appendChild(exportDialog);

            document
              .getElementById("exportDocx")
              .addEventListener("click", async function () {
                await exportAsDocx(notes);
                document.body.removeChild(exportDialog);
              });

            document
              .getElementById("exportTxt")
              .addEventListener("click", async function () {
                await exportAsTxt(notes);
                document.body.removeChild(exportDialog);
              });

            document
              .getElementById("exportCancel")
              .addEventListener("click", function () {
                document.body.removeChild(exportDialog);
              });
          } catch (error) {
            console.error("Export failed:", error);
            showAlert("Failed to export notes", "error");
          }
        });

        importBtn.addEventListener("click", function () {
          const fileInput = document.createElement("input");
          fileInput.type = "file";
          fileInput.accept = ".docx,.txt";

          fileInput.addEventListener("change", async function (e) {
            const file = e.target.files[0];
            if (!file) return;

            try {
              let notes = [];

              if (file.name.endsWith(".docx")) {
                notes = await importDocxFile(file);
              } else if (file.name.endsWith(".txt")) {
                const text = await new Promise((resolve, reject) => {
                  const reader = new FileReader();
                  reader.onload = (event) => resolve(event.target.result);
                  reader.onerror = reject;
                  reader.readAsText(file);
                });
                notes = text
                  .split("\n")
                  .map((line) => line.trim())
                  .filter((line) => line.length > 0)
                  .map((line) => ({ text: line }));
              }

              // Clear existing notes.
              notesList.innerHTML = "";
              try {
                await clearAllNotesFromDB();
              } catch (error) {
                console.error("Failed to clear existing notes:", error);
              }

              // Add new notes.
              let successCount = 0;
              for (const note of notes) {
                try {
                  const text = typeof note === "string" ? note : note.text;
                  const language = note.language || languageSelect.value;
                  const noteId = await saveNoteToDB(text, language);
                  addNoteToUI(text, noteId, language);
                  successCount++;
                } catch (error) {
                  console.error("Failed to import note:", error);
                  const text = typeof note === "string" ? note : note.text;
                  addNoteToUI(text, null, languageSelect.value);
                }
              }

              showAlert(`Successfully imported ${successCount} of ${notes.length} notes`, "success");
            } catch (error) {
              console.error("Import failed:", error);
              showAlert("Failed to import notes. Invalid file format.", "error");
            }
          });

          fileInput.click();
        });

        // Translation button event listener with enhanced error handling
        translateBtn.addEventListener("click", async function () {
          if (
            !textDisplay.textContent.trim() ||
            textDisplay.textContent.trim() ===
              "Your transcribed text will appear here..."
          ) {
            showAlert("Please enter text to translate", "warning");
            return;
          }

          if (!navigator.onLine) {
            showAlert("Translation requires internet connection", "warning");
            return;
          }

          try {
            translateBtn.disabled = true;
            translateBtn.innerHTML =
              '<span class="translation-loading"></span>Translating...';
            translationResult.textContent = "";

            const translation = await translateText(
              textDisplay.textContent.trim(),
              targetLanguage.value
            );
            translationResult.textContent = translation;
            applyTextDirection(translationResult, targetLanguage.value);
          } catch (error) {
            console.error("Translation failed:", error);
            showAlert("Translation failed. Please try again.", "error");
            translationResult.textContent =
              "Translation error: " + error.message;
          } finally {
            translateBtn.disabled = false;
            translateBtn.textContent = "Translate Text";
          }
        });

        languageSelect.addEventListener("change", function () {
          if (recognition) {
            recognition.lang = this.value;
            applyTextDirection(textDisplay, this.value);
            if (isListening) {
              recognition.stop();
              setTimeout(() => recognition.start(), 100);
            }
          }
        });

        function addNoteToUI(text, id, language) {
          const noteItem = document.createElement("li");
          noteItem.className = "note-item";
          noteItem.dataset.id = id || Date.now();

          const noteText = document.createElement("span");
          noteText.textContent = text;

          if (language) {
            const baseLang = language.split("-")[0];
            if (rtlLanguages.includes(baseLang)) {
              noteItem.classList.add("rtl-text");
            }
          }

          const deleteBtn = document.createElement("button");
          deleteBtn.className = "delete-note";
          deleteBtn.innerHTML = "×";
          deleteBtn.addEventListener("click", async function () {
            if (confirm("Delete this note?")) {
              noteItem.remove();
              if (id) {
                try {
                  await deleteNoteFromDB(id);
                  showAlert("Note deleted", "success");
                } catch (error) {
                  console.error("Failed to delete note from DB:", error);
                  showAlert("Failed to delete note from storage", "error");
                }
              }
            }
          });

          // Add touch events for mobile with swipe to delete.
          noteItem.addEventListener(
            "touchstart",
            function (e) {
              touchStartX = e.changedTouches[0].screenX;
              noteItem.classList.add("swiping");
            },
            { passive: true }
          );

          noteItem.addEventListener(
            "touchmove",
            function (e) {
              touchEndX = e.changedTouches[0].screenX;
              const diff = touchStartX - touchEndX;
              if (diff > 30) {
                noteItem.style.transform = `translateX(${-diff}px)`;
                if (diff > 100) {
                  deleteBtn.style.opacity = "1";
                }
              }
            },
            { passive: true }
          );

          noteItem.addEventListener(
            "touchend",
            function () {
              noteItem.classList.remove("swiping");
              const diff = touchStartX - touchEndX;
              if (diff > 100) {
                deleteBtn.click();
              } else {
                noteItem.style.transform = "";
              }
            },
            { passive: true }
          );

          noteItem.appendChild(noteText);
          noteItem.appendChild(deleteBtn);
          notesList.appendChild(noteItem);
          noteItem.scrollIntoView({ behavior: "smooth" });
        }

        textDisplay.addEventListener("keydown", function (e) {
          if (e.key === "Enter") {
            e.preventDefault();
            addNoteBtn.click();
          }
        });

        // Check online status and update UI.
        function updateOnlineStatus() {
          const offlineIndicator = document.getElementById("offlineIndicator");
          if (navigator.onLine) {
            offlineIndicator.style.display = "none";
          } else {
            offlineIndicator.style.display = "block";
          }
        }

        window.addEventListener("online", updateOnlineStatus);
        window.addEventListener("offline", updateOnlineStatus);
        updateOnlineStatus();

        // Page visibility handling.
        document.addEventListener("visibilitychange", function () {
          if (document.visibilityState === "hidden" && isListening) {
            recognition.stop();
          } else if (
            document.visibilityState === "visible" &&
            isAutoListening
          ) {
            setTimeout(() => recognition.start(), 100);
          }
        });

        // Beforeunload handling.
        window.addEventListener("beforeunload", function (e) {
          if (isListening) {
            recognition.stop();
          }
        });
      });

      // Service worker registration.
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("sw.js")
            .then((registration) => {
              console.log("ServiceWorker registration successful.");
            })
            .catch((err) => {
              console.log("ServiceWorker registration failed: ", err);
            });
        });
      }

      // Install prompt handling.
      let deferredPrompt;
      window.addEventListener("beforeinstallprompt", (e) => {
        e.preventDefault();
        deferredPrompt = e;

        const installBtn = document.createElement("button");
        installBtn.className = "install-btn";
        installBtn.innerHTML = `
          <svg class="icon" viewBox="0 0 24 24">
            <path d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M11,16.5L18,9.5L16.59,8.09L11,13.67L7.91,10.59L6.5,12L11,16.5Z" />
          </svg>
          Install App
        `;

        installBtn.addEventListener("click", () => {
          deferredPrompt.prompt();
          deferredPrompt.userChoice.then((choiceResult) => {
            if (choiceResult.outcome === "accepted") {
              console.log("User accepted install.");
            }
            deferredPrompt = null;
            document.body.removeChild(installBtn);
          });
        });

        document.body.appendChild(installBtn);

        setTimeout(() => {
          if (document.body.contains(installBtn)) {
            document.body.removeChild(installBtn);
          }
        }, 15000);
      });
    </script>
  </body>
</html>
